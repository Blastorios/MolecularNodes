[
  {
    "objectID": "reference/data.html",
    "href": "reference/data.html",
    "title": "data",
    "section": "",
    "text": "``\n\n\n\n\n\nName\nDescription\n\n\n\n\nSACCHARIDE_NAMES\n\n\n\nSACCHARIDE_REPRESENTATION\n\n\n\natom_charge\n\n\n\natom_names\n\n\n\nelements\n\n\n\nlipophobicity\n\n\n\nresidues"
  },
  {
    "objectID": "reference/data.html#attributes",
    "href": "reference/data.html#attributes",
    "title": "data",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nSACCHARIDE_NAMES\n\n\n\nSACCHARIDE_REPRESENTATION\n\n\n\natom_charge\n\n\n\natom_names\n\n\n\nelements\n\n\n\nlipophobicity\n\n\n\nresidues"
  },
  {
    "objectID": "reference/esmfold.html",
    "href": "reference/esmfold.html",
    "title": "esmfold",
    "section": "",
    "text": "``\n\n\n\n\n\nName\nDescription\n\n\n\n\nmolecule_esmfold\n\n\n\nopen_structure_esm_fold\n\n\n\npanel\n\n\n\n\n\n\n\nmolecule_esmfold(amino_acid_sequence, MN_name='Name', center_molecule=False, del_solvent=True, include_bonds=True, starting_style=0, setup_nodes=True)\n\n\n\nopen_structure_esm_fold(amino_acid_sequence, include_bonds=True)\n\n\n\npanel(layout_function)"
  },
  {
    "objectID": "reference/esmfold.html#functions",
    "href": "reference/esmfold.html#functions",
    "title": "esmfold",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nmolecule_esmfold\n\n\n\nopen_structure_esm_fold\n\n\n\npanel"
  },
  {
    "objectID": "reference/esmfold.html#esmfold.molecule_esmfold",
    "href": "reference/esmfold.html#esmfold.molecule_esmfold",
    "title": "esmfold",
    "section": "",
    "text": "molecule_esmfold(amino_acid_sequence, MN_name='Name', center_molecule=False, del_solvent=True, include_bonds=True, starting_style=0, setup_nodes=True)"
  },
  {
    "objectID": "reference/esmfold.html#esmfold.open_structure_esm_fold",
    "href": "reference/esmfold.html#esmfold.open_structure_esm_fold",
    "title": "esmfold",
    "section": "",
    "text": "open_structure_esm_fold(amino_acid_sequence, include_bonds=True)"
  },
  {
    "objectID": "reference/esmfold.html#esmfold.panel",
    "href": "reference/esmfold.html#esmfold.panel",
    "title": "esmfold",
    "section": "",
    "text": "panel(layout_function)"
  },
  {
    "objectID": "reference/ui.html",
    "href": "reference/ui.html",
    "title": "ui",
    "section": "",
    "text": "``\n\n\n\n\n\nName\nDescription\n\n\n\n\nMN_PT_panel_ui\n\n\n\nMN_add_node_menu\n\n\n\nMN_change_import_interface\n\n\n\nbutton_custom_color\n\n\n\nbutton_custom_selection\n\n\n\ndefault_style\n\n\n\nmenu_item_interface\n\n\n\npanel_local\n\n\n\npanel_rcsb\n\n\n\n\n\n\n\nMN_PT_panel_ui(layout_function, scene)\n\n\n\nMN_add_node_menu(self, context)\n\n\n\nMN_change_import_interface(layout_function, label, interface_value, icon)\n\n\n\nbutton_custom_color(layout, text, field, prefix, property, node_name, starting_value=0)\n\n\n\nbutton_custom_selection(layout, text, field, prefix, property, node_name, starting_value=0)\n\n\n\ndefault_style(layout, label, panel_display)\n\n\n\nmenu_item_interface(layout_function, label, node_name, node_description='Add custom MolecularNodes node group.', node_link=False)\n\n\n\npanel_local(layout_function)\n\n\n\npanel_rcsb(layout_function)"
  },
  {
    "objectID": "reference/ui.html#functions",
    "href": "reference/ui.html#functions",
    "title": "ui",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nMN_PT_panel_ui\n\n\n\nMN_add_node_menu\n\n\n\nMN_change_import_interface\n\n\n\nbutton_custom_color\n\n\n\nbutton_custom_selection\n\n\n\ndefault_style\n\n\n\nmenu_item_interface\n\n\n\npanel_local\n\n\n\npanel_rcsb"
  },
  {
    "objectID": "reference/ui.html#ui.MN_PT_panel_ui",
    "href": "reference/ui.html#ui.MN_PT_panel_ui",
    "title": "ui",
    "section": "",
    "text": "MN_PT_panel_ui(layout_function, scene)"
  },
  {
    "objectID": "reference/ui.html#ui.MN_add_node_menu",
    "href": "reference/ui.html#ui.MN_add_node_menu",
    "title": "ui",
    "section": "",
    "text": "MN_add_node_menu(self, context)"
  },
  {
    "objectID": "reference/ui.html#ui.MN_change_import_interface",
    "href": "reference/ui.html#ui.MN_change_import_interface",
    "title": "ui",
    "section": "",
    "text": "MN_change_import_interface(layout_function, label, interface_value, icon)"
  },
  {
    "objectID": "reference/ui.html#ui.button_custom_color",
    "href": "reference/ui.html#ui.button_custom_color",
    "title": "ui",
    "section": "",
    "text": "button_custom_color(layout, text, field, prefix, property, node_name, starting_value=0)"
  },
  {
    "objectID": "reference/ui.html#ui.button_custom_selection",
    "href": "reference/ui.html#ui.button_custom_selection",
    "title": "ui",
    "section": "",
    "text": "button_custom_selection(layout, text, field, prefix, property, node_name, starting_value=0)"
  },
  {
    "objectID": "reference/ui.html#ui.default_style",
    "href": "reference/ui.html#ui.default_style",
    "title": "ui",
    "section": "",
    "text": "default_style(layout, label, panel_display)"
  },
  {
    "objectID": "reference/ui.html#ui.menu_item_interface",
    "href": "reference/ui.html#ui.menu_item_interface",
    "title": "ui",
    "section": "",
    "text": "menu_item_interface(layout_function, label, node_name, node_description='Add custom MolecularNodes node group.', node_link=False)"
  },
  {
    "objectID": "reference/ui.html#ui.panel_local",
    "href": "reference/ui.html#ui.panel_local",
    "title": "ui",
    "section": "",
    "text": "panel_local(layout_function)"
  },
  {
    "objectID": "reference/ui.html#ui.panel_rcsb",
    "href": "reference/ui.html#ui.panel_rcsb",
    "title": "ui",
    "section": "",
    "text": "panel_rcsb(layout_function)"
  },
  {
    "objectID": "reference/index.html",
    "href": "reference/index.html",
    "title": "Function reference",
    "section": "",
    "text": "The Python code that powers Molecular Nodes under the hood.\n\n\n\npkg\nHandling installation of external python packages inside of Blender’s bundled python.\n\n\nload\n\n\n\nnodes\n\n\n\ncoll\n\n\n\ndensity\n\n\n\ndata\n\n\n\nmd\nImporting molecular dynamics trajectories and associated files.\n\n\nstar\n\n\n\nesmfold\n\n\n\nobj\n\n\n\nui\n\n\n\nassembly\nA subpackage for reading rotation matrices and translation vectors"
  },
  {
    "objectID": "reference/index.html#python-api",
    "href": "reference/index.html#python-api",
    "title": "Function reference",
    "section": "",
    "text": "The Python code that powers Molecular Nodes under the hood.\n\n\n\npkg\nHandling installation of external python packages inside of Blender’s bundled python.\n\n\nload\n\n\n\nnodes\n\n\n\ncoll\n\n\n\ndensity\n\n\n\ndata\n\n\n\nmd\nImporting molecular dynamics trajectories and associated files.\n\n\nstar\n\n\n\nesmfold\n\n\n\nobj\n\n\n\nui\n\n\n\nassembly\nA subpackage for reading rotation matrices and translation vectors"
  },
  {
    "objectID": "reference/density.html",
    "href": "reference/density.html",
    "title": "density",
    "section": "",
    "text": "``\n\n\n\n\n\nName\nDescription\n\n\n\n\nload\nLoads an MRC file into Blender as a volumetric object.\n\n\nmap_to_grid\nReads an MRC file and converts it into a pyopenvdb FloatGrid object.\n\n\nmap_to_vdb\nConverts an MRC file to a .vdb file using pyopenvdb.\n\n\npanel\n\n\n\npath_to_vdb\nConvert a file path to a corresponding VDB file path.\n\n\nvdb_to_volume\nImports a VDB file as a Blender volume object.\n\n\n\n\n\n\nload(file, name=None, invert=False, world_scale=0.01)\nLoads an MRC file into Blender as a volumetric object.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nfile\nstr\nPath to the MRC file.\nrequired\n\n\nname\nstr, optional\nIf not None, renames the object with the new name.\nNone\n\n\ninvert\nbool, optional\nWhether to invert the data from the grid, defaulting to False. Some file types such as EM tomograms have inverted values, where a high value == low density.\nFalse\n\n\nworld_scale\nfloat, optional\nScale of the object in the world. Defaults to 0.01.\n0.01\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nbpy.types.Object\nThe loaded volumetric object.\n\n\n\n\n\n\n\nmap_to_grid(file, invert=False)\nReads an MRC file and converts it into a pyopenvdb FloatGrid object.\nThis function reads a file in MRC format, and converts it into a pyopenvdb FloatGrid object, which can be used to represent volumetric data in Blender.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nfile\nstr\nThe path to the MRC file.\nrequired\n\n\ninvert\nbool, optional\nWhether to invert the data from the grid, defaulting to False. Some file types such as EM tomograms have inverted values, where a high value == low density.\nFalse\n\n\n\n\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\npyopenvdb.FloatGrid\nA pyopenvdb FloatGrid object containing the density data.\n\n\n\n\n\n\n\nmap_to_vdb(file, invert=False, world_scale=0.01, overwrite=False)\nConverts an MRC file to a .vdb file using pyopenvdb.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nfile\nstr\nThe path to the input MRC file.\nrequired\n\n\ninvert\nbool, optional\nWhether to invert the data from the grid, defaulting to False. Some file types such as EM tomograms have inverted values, where a high value == low density.\nFalse\n\n\nworld_scale\nfloat, optional\nThe scaling factor to apply to the voxel size of the input file. Defaults to 0.01.\n0.01\n\n\noverwrite\nbool, optional\nIf True, the .vdb file will be overwritten if it already exists. Defaults to False.\nFalse\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nstr\nThe path to the converted .vdb file.\n\n\n\n\n\n\n\npanel(layout_function, scene)\n\n\n\npath_to_vdb(file)\nConvert a file path to a corresponding VDB file path.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nfile\nstr\nThe path of the original file.\nrequired\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nstr\nThe path of the corresponding VDB file.\n\n\n\n\n\n\n\nvdb_to_volume(file)\nImports a VDB file as a Blender volume object.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nfile\nstr\nPath to the VDB file.\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nbpy.types.Object\nA Blender object containing the imported volume data."
  },
  {
    "objectID": "reference/density.html#functions",
    "href": "reference/density.html#functions",
    "title": "density",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nload\nLoads an MRC file into Blender as a volumetric object.\n\n\nmap_to_grid\nReads an MRC file and converts it into a pyopenvdb FloatGrid object.\n\n\nmap_to_vdb\nConverts an MRC file to a .vdb file using pyopenvdb.\n\n\npanel\n\n\n\npath_to_vdb\nConvert a file path to a corresponding VDB file path.\n\n\nvdb_to_volume\nImports a VDB file as a Blender volume object."
  },
  {
    "objectID": "reference/density.html#density.load",
    "href": "reference/density.html#density.load",
    "title": "density",
    "section": "",
    "text": "load(file, name=None, invert=False, world_scale=0.01)\nLoads an MRC file into Blender as a volumetric object.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nfile\nstr\nPath to the MRC file.\nrequired\n\n\nname\nstr, optional\nIf not None, renames the object with the new name.\nNone\n\n\ninvert\nbool, optional\nWhether to invert the data from the grid, defaulting to False. Some file types such as EM tomograms have inverted values, where a high value == low density.\nFalse\n\n\nworld_scale\nfloat, optional\nScale of the object in the world. Defaults to 0.01.\n0.01\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nbpy.types.Object\nThe loaded volumetric object."
  },
  {
    "objectID": "reference/density.html#density.map_to_grid",
    "href": "reference/density.html#density.map_to_grid",
    "title": "density",
    "section": "",
    "text": "map_to_grid(file, invert=False)\nReads an MRC file and converts it into a pyopenvdb FloatGrid object.\nThis function reads a file in MRC format, and converts it into a pyopenvdb FloatGrid object, which can be used to represent volumetric data in Blender.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nfile\nstr\nThe path to the MRC file.\nrequired\n\n\ninvert\nbool, optional\nWhether to invert the data from the grid, defaulting to False. Some file types such as EM tomograms have inverted values, where a high value == low density.\nFalse\n\n\n\n\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\npyopenvdb.FloatGrid\nA pyopenvdb FloatGrid object containing the density data."
  },
  {
    "objectID": "reference/density.html#density.map_to_vdb",
    "href": "reference/density.html#density.map_to_vdb",
    "title": "density",
    "section": "",
    "text": "map_to_vdb(file, invert=False, world_scale=0.01, overwrite=False)\nConverts an MRC file to a .vdb file using pyopenvdb.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nfile\nstr\nThe path to the input MRC file.\nrequired\n\n\ninvert\nbool, optional\nWhether to invert the data from the grid, defaulting to False. Some file types such as EM tomograms have inverted values, where a high value == low density.\nFalse\n\n\nworld_scale\nfloat, optional\nThe scaling factor to apply to the voxel size of the input file. Defaults to 0.01.\n0.01\n\n\noverwrite\nbool, optional\nIf True, the .vdb file will be overwritten if it already exists. Defaults to False.\nFalse\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nstr\nThe path to the converted .vdb file."
  },
  {
    "objectID": "reference/density.html#density.panel",
    "href": "reference/density.html#density.panel",
    "title": "density",
    "section": "",
    "text": "panel(layout_function, scene)"
  },
  {
    "objectID": "reference/density.html#density.path_to_vdb",
    "href": "reference/density.html#density.path_to_vdb",
    "title": "density",
    "section": "",
    "text": "path_to_vdb(file)\nConvert a file path to a corresponding VDB file path.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nfile\nstr\nThe path of the original file.\nrequired\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nstr\nThe path of the corresponding VDB file."
  },
  {
    "objectID": "reference/density.html#density.vdb_to_volume",
    "href": "reference/density.html#density.vdb_to_volume",
    "title": "density",
    "section": "",
    "text": "vdb_to_volume(file)\nImports a VDB file as a Blender volume object.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nfile\nstr\nPath to the VDB file.\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nbpy.types.Object\nA Blender object containing the imported volume data."
  },
  {
    "objectID": "reference/load.html",
    "href": "reference/load.html",
    "title": "load",
    "section": "",
    "text": "``\n\n\n\n\n\nName\nDescription\n\n\n\n\ncomp_secondary_structure\nUse dihedrals to compute the secondary structure of proteins\n\n\ncreate_molecule\n\n\n\nget_chain_entity_id\n\n\n\nget_secondary_structure\nGets the secondary structure annotation that is included in mmtf files and returns it as a numerical numpy array.\n\n\nmolecule_local\n\n\n\nmolecule_rcsb\n\n\n\nopen_structure_local_pdb\n\n\n\nopen_structure_local_pdbx\n\n\n\nopen_structure_rcsb\n\n\n\npdb_get_b_factors\nGet a list, which contains a numpy array for each model containing the b-factors.\n\n\nset_atom_entity_id\n\n\n\n\n\n\n\ncomp_secondary_structure(MN_array)\nUse dihedrals to compute the secondary structure of proteins\nThrough biotite built-in method derivated from P-SEA algorithm (Labesse 1997) Returns an array with secondary structure for each atoms where: - 0 = ’’ = non-protein or not assigned by biotite annotate_sse - 1 = a = alpha helix - 2 = b = beta sheet - 3 = c = coil\nInspired from https://www.biotite-python.org/examples/gallery/structure/transketolase_sse.html\n\n\n\ncreate_molecule(MN_array, MN_name, center_molecule=False, file=None, calculate_ss=False, del_solvent=False, include_bonds=False, starting_style=0, collection=None)\n\n\n\nget_chain_entity_id(file)\n\n\n\nget_secondary_structure(MN_array, file)\n\n\nMN_array : numpy.array The molecular coordinates array, from mmtf.get_structure() file : mmtf.MMTFFile The MMTF file containing the secondary structure information, from mmtf.MMTFFile.read()\n\n\n\natom_sse : numpy.array Numerical numpy array representing the secondary structure of the molecule.\n\n\n\nThis function uses the biotite.structure package to extract the secondary structure information from the MMTF file. The resulting secondary structures are 1: Alpha Helix, 2: Beta-sheet, 3: loop.\n\n\n\n\nmolecule_local(file_path, MN_name='Name', include_bonds=True, center_molecule=False, del_solvent=True, default_style=0, setup_nodes=True)\n\n\n\nmolecule_rcsb(pdb_code, center_molecule=False, del_solvent=True, include_bonds=True, starting_style=0, setup_nodes=True, cache_dir=None)\n\n\n\nopen_structure_local_pdb(file_path, include_bonds=True)\n\n\n\nopen_structure_local_pdbx(file_path, include_bonds=True)\n\n\n\nopen_structure_rcsb(pdb_code, cache_dir=None, include_bonds=True)\n\n\n\npdb_get_b_factors(file)\nGet a list, which contains a numpy array for each model containing the b-factors.\n\n\n\nset_atom_entity_id(mol, file)"
  },
  {
    "objectID": "reference/load.html#functions",
    "href": "reference/load.html#functions",
    "title": "load",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\ncomp_secondary_structure\nUse dihedrals to compute the secondary structure of proteins\n\n\ncreate_molecule\n\n\n\nget_chain_entity_id\n\n\n\nget_secondary_structure\nGets the secondary structure annotation that is included in mmtf files and returns it as a numerical numpy array.\n\n\nmolecule_local\n\n\n\nmolecule_rcsb\n\n\n\nopen_structure_local_pdb\n\n\n\nopen_structure_local_pdbx\n\n\n\nopen_structure_rcsb\n\n\n\npdb_get_b_factors\nGet a list, which contains a numpy array for each model containing the b-factors.\n\n\nset_atom_entity_id"
  },
  {
    "objectID": "reference/load.html#load.comp_secondary_structure",
    "href": "reference/load.html#load.comp_secondary_structure",
    "title": "load",
    "section": "",
    "text": "comp_secondary_structure(MN_array)\nUse dihedrals to compute the secondary structure of proteins\nThrough biotite built-in method derivated from P-SEA algorithm (Labesse 1997) Returns an array with secondary structure for each atoms where: - 0 = ’’ = non-protein or not assigned by biotite annotate_sse - 1 = a = alpha helix - 2 = b = beta sheet - 3 = c = coil\nInspired from https://www.biotite-python.org/examples/gallery/structure/transketolase_sse.html"
  },
  {
    "objectID": "reference/load.html#load.create_molecule",
    "href": "reference/load.html#load.create_molecule",
    "title": "load",
    "section": "",
    "text": "create_molecule(MN_array, MN_name, center_molecule=False, file=None, calculate_ss=False, del_solvent=False, include_bonds=False, starting_style=0, collection=None)"
  },
  {
    "objectID": "reference/load.html#load.get_chain_entity_id",
    "href": "reference/load.html#load.get_chain_entity_id",
    "title": "load",
    "section": "",
    "text": "get_chain_entity_id(file)"
  },
  {
    "objectID": "reference/load.html#load.get_secondary_structure",
    "href": "reference/load.html#load.get_secondary_structure",
    "title": "load",
    "section": "",
    "text": "get_secondary_structure(MN_array, file)\n\n\nMN_array : numpy.array The molecular coordinates array, from mmtf.get_structure() file : mmtf.MMTFFile The MMTF file containing the secondary structure information, from mmtf.MMTFFile.read()\n\n\n\natom_sse : numpy.array Numerical numpy array representing the secondary structure of the molecule.\n\n\n\nThis function uses the biotite.structure package to extract the secondary structure information from the MMTF file. The resulting secondary structures are 1: Alpha Helix, 2: Beta-sheet, 3: loop."
  },
  {
    "objectID": "reference/load.html#load.molecule_local",
    "href": "reference/load.html#load.molecule_local",
    "title": "load",
    "section": "",
    "text": "molecule_local(file_path, MN_name='Name', include_bonds=True, center_molecule=False, del_solvent=True, default_style=0, setup_nodes=True)"
  },
  {
    "objectID": "reference/load.html#load.molecule_rcsb",
    "href": "reference/load.html#load.molecule_rcsb",
    "title": "load",
    "section": "",
    "text": "molecule_rcsb(pdb_code, center_molecule=False, del_solvent=True, include_bonds=True, starting_style=0, setup_nodes=True, cache_dir=None)"
  },
  {
    "objectID": "reference/load.html#load.open_structure_local_pdb",
    "href": "reference/load.html#load.open_structure_local_pdb",
    "title": "load",
    "section": "",
    "text": "open_structure_local_pdb(file_path, include_bonds=True)"
  },
  {
    "objectID": "reference/load.html#load.open_structure_local_pdbx",
    "href": "reference/load.html#load.open_structure_local_pdbx",
    "title": "load",
    "section": "",
    "text": "open_structure_local_pdbx(file_path, include_bonds=True)"
  },
  {
    "objectID": "reference/load.html#load.open_structure_rcsb",
    "href": "reference/load.html#load.open_structure_rcsb",
    "title": "load",
    "section": "",
    "text": "open_structure_rcsb(pdb_code, cache_dir=None, include_bonds=True)"
  },
  {
    "objectID": "reference/load.html#load.pdb_get_b_factors",
    "href": "reference/load.html#load.pdb_get_b_factors",
    "title": "load",
    "section": "",
    "text": "pdb_get_b_factors(file)\nGet a list, which contains a numpy array for each model containing the b-factors."
  },
  {
    "objectID": "reference/load.html#load.set_atom_entity_id",
    "href": "reference/load.html#load.set_atom_entity_id",
    "title": "load",
    "section": "",
    "text": "set_atom_entity_id(mol, file)"
  },
  {
    "objectID": "reference/obj.html",
    "href": "reference/obj.html",
    "title": "obj",
    "section": "",
    "text": "``\n\n\n\n\n\nName\nDescription\n\n\n\n\nadd_attribute\nAdd an attribute to the given object’s geometry on the given domain.\n\n\ncreate_object\nCreate a mesh with the given name in the given collection, using the supplied\n\n\nget_attribute\nRetrieve an attribute from the object as a NumPy array.\n\n\n\n\n\n\nadd_attribute(object, name, data, type='FLOAT', domain='POINT')\nAdd an attribute to the given object’s geometry on the given domain.\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nAny\nThe newly created attribute, which can be further manipulated or used in the 3D environment.\n\n\n\n\n\n\n- The function supports adding both scalar and vector attributes.\n- The \"FLOAT_VECTOR\" attribute requires the input data to be a 1D array, and it will be reshaped internally\n  to represent vectors with 3 components (x, y, z).\n\n\n\n\ncreate_object(name, collection, locations, bonds=\\[\\])\nCreate a mesh with the given name in the given collection, using the supplied vertex locations and, if provided, bonds as edges.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nname\nstr\nThe name of the mesh object to be created.\nrequired\n\n\ncollection\nbpy.types.Collection\nThe collection to which the mesh object will be added.\nrequired\n\n\nlocations\narray-like\nThe list of vertex locations for the mesh, an nx3 np array of locations. Each element in the list represents a 3D point (x, y, z) for a vertex.\nrequired\n\n\nbonds\nlist of tuples, optional\nThe list of vertex index pairs representing bonds as edges for the mesh. Each tuple should contain two vertex indices (e.g., (index1, index2)).\n[]\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nbpy.types.Object\nThe newly created mesh object.\n\n\n\n\n\n\n\nThe ‘name’ should be a unique identifier for the created mesh object.\nThe ‘locations’ list should contain at least three 3D points to define a 3D triangle.\nIf ‘bonds’ are not provided, the mesh will have no edges.\nIf ‘bonds’ are provided, they should be valid vertex indices within the ‘locations’ list.\n\n\n\n\n# Create a mesh object named \"MyMesh\" in the collection \"MyCollection\"\n# with vertex locations and bond edges.\nlocations = [[0.0, 0.0, 0.0], [1.0, 0.0, 0.0], [1.0, 1.0, 0.0]]\nbonds = [(0, 1), (1, 2), (2, 0)]\nmy_object = create_object(\"MyMesh\", bpy.data.collections['Collection'], locations, bonds)\n\n\n\n\nget_attribute(obj, att_name='position')\nRetrieve an attribute from the object as a NumPy array.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nobj\nbpy.types.Object\nThe Blender object from which the attribute will be retrieved.\nrequired\n\n\natt_name\nstr, optional\nThe name of the attribute to retrieve. Default is ‘position’.\n'position'\n\n\nReturns\n\n\nrequired\n\n\nnp\n\nThe attribute data as a NumPy array.\nrequired\n\n\n\n\n\n\n\nThis function retrieves the specified attribute from the object and returns it as a NumPy array.\nThe function assumes that the attribute data type is one of [‘INT’, ‘FLOAT’, ‘BOOLEAN’, ‘FLOAT_VECTOR’].\n\n\n\n\n# Assuming 'my_object' is a Blender object with an attribute named 'my_attribute'\nattribute_data = get_attribute(my_object, 'my_attribute')"
  },
  {
    "objectID": "reference/obj.html#functions",
    "href": "reference/obj.html#functions",
    "title": "obj",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nadd_attribute\nAdd an attribute to the given object’s geometry on the given domain.\n\n\ncreate_object\nCreate a mesh with the given name in the given collection, using the supplied\n\n\nget_attribute\nRetrieve an attribute from the object as a NumPy array."
  },
  {
    "objectID": "reference/obj.html#obj.add_attribute",
    "href": "reference/obj.html#obj.add_attribute",
    "title": "obj",
    "section": "",
    "text": "add_attribute(object, name, data, type='FLOAT', domain='POINT')\nAdd an attribute to the given object’s geometry on the given domain.\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nAny\nThe newly created attribute, which can be further manipulated or used in the 3D environment.\n\n\n\n\n\n\n- The function supports adding both scalar and vector attributes.\n- The \"FLOAT_VECTOR\" attribute requires the input data to be a 1D array, and it will be reshaped internally\n  to represent vectors with 3 components (x, y, z)."
  },
  {
    "objectID": "reference/obj.html#obj.create_object",
    "href": "reference/obj.html#obj.create_object",
    "title": "obj",
    "section": "",
    "text": "create_object(name, collection, locations, bonds=\\[\\])\nCreate a mesh with the given name in the given collection, using the supplied vertex locations and, if provided, bonds as edges.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nname\nstr\nThe name of the mesh object to be created.\nrequired\n\n\ncollection\nbpy.types.Collection\nThe collection to which the mesh object will be added.\nrequired\n\n\nlocations\narray-like\nThe list of vertex locations for the mesh, an nx3 np array of locations. Each element in the list represents a 3D point (x, y, z) for a vertex.\nrequired\n\n\nbonds\nlist of tuples, optional\nThe list of vertex index pairs representing bonds as edges for the mesh. Each tuple should contain two vertex indices (e.g., (index1, index2)).\n[]\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nbpy.types.Object\nThe newly created mesh object.\n\n\n\n\n\n\n\nThe ‘name’ should be a unique identifier for the created mesh object.\nThe ‘locations’ list should contain at least three 3D points to define a 3D triangle.\nIf ‘bonds’ are not provided, the mesh will have no edges.\nIf ‘bonds’ are provided, they should be valid vertex indices within the ‘locations’ list.\n\n\n\n\n# Create a mesh object named \"MyMesh\" in the collection \"MyCollection\"\n# with vertex locations and bond edges.\nlocations = [[0.0, 0.0, 0.0], [1.0, 0.0, 0.0], [1.0, 1.0, 0.0]]\nbonds = [(0, 1), (1, 2), (2, 0)]\nmy_object = create_object(\"MyMesh\", bpy.data.collections['Collection'], locations, bonds)"
  },
  {
    "objectID": "reference/obj.html#obj.get_attribute",
    "href": "reference/obj.html#obj.get_attribute",
    "title": "obj",
    "section": "",
    "text": "get_attribute(obj, att_name='position')\nRetrieve an attribute from the object as a NumPy array.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nobj\nbpy.types.Object\nThe Blender object from which the attribute will be retrieved.\nrequired\n\n\natt_name\nstr, optional\nThe name of the attribute to retrieve. Default is ‘position’.\n'position'\n\n\nReturns\n\n\nrequired\n\n\nnp\n\nThe attribute data as a NumPy array.\nrequired\n\n\n\n\n\n\n\nThis function retrieves the specified attribute from the object and returns it as a NumPy array.\nThe function assumes that the attribute data type is one of [‘INT’, ‘FLOAT’, ‘BOOLEAN’, ‘FLOAT_VECTOR’].\n\n\n\n\n# Assuming 'my_object' is a Blender object with an attribute named 'my_attribute'\nattribute_data = get_attribute(my_object, 'my_attribute')"
  },
  {
    "objectID": "tutorials/01_importing.html",
    "href": "tutorials/01_importing.html",
    "title": "Fetch from the PDB",
    "section": "",
    "text": "Molecules, simulations and other file formats can all be imported via the Molecular Nodes subpanel. This panel can be found under the Scene Properties panel. This is the small cone and spheres icon on the right. This contains all of the different options for importing molecular data currently available inside of Molecular Nodes.\nYou can download a structure directly from the PDB, just from the accession code. Molecular Nodes will download the file as a .mmtf file and cache it locally on your computer, then open the file in to Blender. This is the quickest way to import structures that are already available via the wwPDB. Currently this downloads via the RCSB.\nTo download directly from the PDB, you can use the PDB tab."
  },
  {
    "objectID": "tutorials/01_importing.html#pdb-tab",
    "href": "tutorials/01_importing.html#pdb-tab",
    "title": "Fetch from the PDB",
    "section": "PDB Tab",
    "text": "PDB Tab\nIn this tab you can input the PDB ID to be used for downloading the structure. You can also change where Molecular Nodes caches the downloaded structures. By default it will be in a hidden .MolecularNodes folder in your home directory.\n\n\n\nThe PDB import tab.\n\n\nType in the code, choose your import options such as starting style, and click download. The new object will appear in the outliner. It will appear inside of the MolecularNodes collection and should have the name of the PDB ID used to fetch the structure. If an object already exists with that name, it will be appended with a .001 or similar suffix.\nThe molecule may appear inside of the default cube, so you may have to delete it before the protein becomes visible.\n\n\nVideo\nDownloading 4OZS from the PDB"
  },
  {
    "objectID": "tutorials/01_importing.html#edit-mode",
    "href": "tutorials/01_importing.html#edit-mode",
    "title": "Fetch from the PDB",
    "section": "Edit Mode",
    "text": "Edit Mode\nThe protein is imported as a 3D mesh, with a vertex for each atom and an edge for each bond. What you are seeing is the result of passing that data through a geometry-processing pipeline. The underlying data is still available, and you can even look at it (and edit it if you wish) by going using edit mode with Tab\nYou are editing the underlying atomic data, not the cartoon itself. The cartoon is rebuilt on top of the edited atomic data, which is why part of it also moves with the atoms when they are moved.\nIt is probably ill-advised to manually edit the atomic data by hand, but it is important to understand the structure of the data inside of Blender & Molecular Nodes.\nVideo"
  },
  {
    "objectID": "tutorials/01_importing.html#rendered-views",
    "href": "tutorials/01_importing.html#rendered-views",
    "title": "Fetch from the PDB",
    "section": "Rendered Views",
    "text": "Rendered Views\nWhile the molecule is imported, we are in 3D view by default. We can change to a rendered view to view the molecule with more accurately calculated lighting effects.\n\n\nVideo\nChanging to rendered views in different rendering engines."
  },
  {
    "objectID": "tutorials/01_importing.html#changing-styles",
    "href": "tutorials/01_importing.html#changing-styles",
    "title": "Fetch from the PDB",
    "section": "Changing Styles",
    "text": "Changing Styles\nThe protein is now imported in the scene. To change the way the protein is displayed, we have to use the Geometry Nodes editor. This is where we change the nodes that are use to process the underlying atomic data, resulting in the final 3D object we can see in front of us.\nTo access Geometry Nodes panel, we can either select the Geoemtry Nodes workspace, or split the current viewport and change one of the workspaces into the node editor.\n\n\nVideo\nArranging workspaces.\n\n\nYou can change the workspace through the tabs in the top of Blender. You can split workspaces by hovering over the corner of a workspace, and then clicking and dragging. You can merge to workspaces by clicking and dragging from one into another, while dragging into the same workspace will split it and create two workspaces.\n\n\nVideo\nOpening the Geometry Nodes workspaces.\n\n\nGeometry node trees are explained more in the next section.\nIn short, the atomic data comes through the Group Input on the left, and the final 3D model goes out the Group Output to the right. Each node in between performs some actions on the data. The first node changes the colours of the atoms. The last node applies the given style. When importing we chose the Cartoon style default, so we have a cartoon node.\nWe can add a new node through the Add menu, or we can use Shift + A to add new nodes. We can click and drag on the noodle outputs and inputs to remove and create new connections. Notice how when the complete ‘circuit’ or ‘flow diagram’ goes through the ball and stick node, the style changes to ball and stick. When it flows through the cartoon node, the style changes to cartoon.\n\n\nVideo\nAdding a new node to change the output style."
  },
  {
    "objectID": "tutorials/01_importing.html#geometry-nodes-editor",
    "href": "tutorials/01_importing.html#geometry-nodes-editor",
    "title": "Fetch from the PDB",
    "section": "Geometry Nodes Editor",
    "text": "Geometry Nodes Editor\nThis is where we edit the node graph for Molecular Nodes. The node graph is a geometry processing program you create, that is read and executed by Blender from left to right. Each node performs an action on the geometry that is passed into it, and the result of that action is passed out to the right. Think of it as creating a set of rules for the computer to follow. You define the rules, and the computer can follow those same rules, even if you start with a different data set.\nThe data flows like a river, along the green noodles of the node graph. There must be only 1 final output. If you are using the molecular data, then there must also be a single input.\n\n\n\nExample node tree, demonstrating the flow of information through the nodes.\n\n\nThe data flows from left to right, like water through a river.\n\n\n\n\nflowchart LR\n  A{Atomic\\nData} --&gt; B[Manipulation]\n  B --&gt; D(Style)\n  D --&gt; G{Geometry\\nOutput}\n\n\n\n\n\n\n\n\nScreenshot of the Geometry Nodes workspace.\n\n\nThe starting style MOL_style_atoms_cycles is only visible via inside of the Cycles render engine. You can add other styles manipulate the data through other nodes, by adding them with Shift + A and navigating to the MolecularNodes panel at the bottom. There are several categories of nodes for different animations and styles. You can add the Ribbon Protein node, which will create a ribbon representation based on the alpha carbons in the structure. If there is not colour in the structure, ensure that the node has a material MOL_atomic_material at the bottom of the node.\n\nThe data flows through the node graph from left to right. There should always be one input, which is the atomic data that is stored in the 3D mesh of the atoms and bonds. There should also be only one output, which is the final geometry that has been created throughout the node graph.\n\n\n\n\nflowchart LR\n  A{Atomic\\nData} --&gt; B[Manipulation]\n\n  B --&gt; D(Style 1)\n  B --&gt; E(Style 2)\n  B --&gt; S(Style 3)\n\n  sS[Selection] --&gt; S\n\n  E --&gt; F[Join\\nGeometry]\n  D --&gt; F\n  S --&gt; F\n\n  F --&gt; G{Geometry\\nOutput}\n\n\n\n\n\nAs demonstrated in the diagram, the flow of the data can split across multiple different branches of the tree, with the result of each parallel computation being combined before being exported.\nEach of these different branches can be a different style, in this example shown two different styles are applied, and the third style has a custom selection. All of the styles are the result of the same data manipulation.\nThe node graph in between can be as complex as you want to make it, as long as there is a continuous connection to the output of the geometry, it should produce a result.\n\n\n\nAn example of a more complex node graph, with multiple branches that diverge and come back together.\n\n\nCombining multiple different nodes you can create protein models and complex 3D scenes. In the example below, there is a node tree which should be present on every new structure imported via MolecularNodes. The atoms and bonds are passed in from the left, the atoms are given a colour based on their element and their chain_id, and then the atoms are styled as atoms, scaling the atom radii to 1.00.\nThe data flows through the node tree from left to right, along the bright green lines. The atomic data comes in, goes through layers of manipulation, a style is applied, and the created geometry is then outputted from the node tree.\n\nEditing the Styles\nTo change how each style looks, you can edit the default values of the nodes. By changing the values, you change the numbers that are used in the creation of the 3D models. The style will only change if it is being output through the node tree. You can click and drag to change the values smoothly. You can hold Shift while dragging the values to change them more accurately.\n\n\nVideo\nTweaking the default values of the styles."
  },
  {
    "objectID": "tutorials/01_importing.html#combining-styles",
    "href": "tutorials/01_importing.html#combining-styles",
    "title": "Fetch from the PDB",
    "section": "Combining Styles",
    "text": "Combining Styles\nTo complete this tutorial, we will combine the use of Selection and Join Geometry to create a style which shows the side chains as ball and stick while also showing the cartoon style.\nThe style should usually be the last node that you apply to a model. You can’t apply a style after another style, as the output of a style is 3D geometry and not ‘atom-like’ geometry. Instead, we can combine two styles with a Join Geometry node. That way, we create both styles in parallel and then join them together before outputting them all through the Group Output node.\nThe node can be found under Geometry or by going through the search for Join Geometry\n\n\nVideo\nAdding a Join Geometry node."
  },
  {
    "objectID": "tutorials/01_importing.html#selections",
    "href": "tutorials/01_importing.html#selections",
    "title": "Fetch from the PDB",
    "section": "Selections",
    "text": "Selections\nMany nodes will have a Selection input, which you can’t manually edit. This input is a Boolean attribute and says whether or not to apply an operation to atoms based on if the value is True or False.\nYou can use selections via the Molecular Nodes -&gt; Selection menu. In this example we use the Backbone node to select atoms based on if they are part of the backbone, the side chain, or just alpha carbons.\nYou can see as we connect different outputs from the Backbone node, we get different results in the final style.\n\n\nVideo\nChanging selections for the Ball and Stick style."
  },
  {
    "objectID": "tutorials/00_interface.html",
    "href": "tutorials/00_interface.html",
    "title": "Blender’s Interface",
    "section": "",
    "text": "Blender has a very overwhelming interface. There is no getting around this. Blender can do practically anything, and it is sometimes hard to do simple things."
  },
  {
    "objectID": "tutorials/00_interface.html#transforming-objects",
    "href": "tutorials/00_interface.html#transforming-objects",
    "title": "Blender’s Interface",
    "section": "Transforming Objects",
    "text": "Transforming Objects\nThe main difference is that you can also manipulate the 3D scene in front of you. You can select objects with a left click of the mouse LMB, and move them around by Grabbing them with the G key.\nThe main actions that you use the 3D Viewport for are:\n\n\nG - Grabbing: Moving an object around in 3D space.\nS - Scaling: Changing the relative size of an object.\nR - Rotating: Rotating the object in 3D space.\n\nVideo\n\nLocking to an Axis\nWhen transforming by grabbing, rotating or scaling, you can lock the transformation to a particular axis. Click X / Y / Z after starting the transformation to lock it to those axes, or Shift + X / Y / Z to lock the transformation to be perpendicular to that axis.\nVideo"
  },
  {
    "objectID": "tutorials/00_interface.html#rendered-view",
    "href": "tutorials/00_interface.html#rendered-view",
    "title": "Blender’s Interface",
    "section": "Rendered View",
    "text": "Rendered View\nBy default you start in 3D View, which is characterised by everything being gray and not rendered properly.\nYou can change to the different views via the render view buttons, or by holding Z and selecting one of the options.\nEach of the views are useful in their own way. If you have a powerful enough computer, you can spend the majority of your time in either Rendered or Material Preview view which will ensure everything is shaded and lighting is calculated. If a scene is becoming complex and your computer is slow, you can switch back to 3D View which should improve performance.\nVideo"
  },
  {
    "objectID": "tutorials/00_interface.html#rendering-engines",
    "href": "tutorials/00_interface.html#rendering-engines",
    "title": "Blender’s Interface",
    "section": "Rendering Engines",
    "text": "Rendering Engines\nAlready there are different ways to view the scene, through the ‘rendered view’ and the other methods. Even with the option of rendered view, there are multiple different rendering engines. Two rendering engines come pre-installed with Blender, with the possibility to use more. The two rendering engines that come pre-installed are Eevee and Cycles. By default Eevee is enabled, but you can change to Cycles in the Render Properties tab.\nEevee is much faster and more responsive than Cycles, but a lot of the time doesn’t ‘look as nice’. Eevee is a real-time rendering engine built for performance and interactivity, while Cycles is a path-traced rendering engine built for physically accurate light calculations. This is much slower to calculate but often results in ‘nicer’ lighting. Both rendering engines are excellent and are helpful in different scenarios depending on the desired outcomes.\nThe default style Atoms Cycles inside of Molecular Nodes is only visible inside of Cycles for performance reasons. All other styles are visible inside of both rendering engines. If your atoms seem to be invisible, check the rendering engine and style that you are using.\n\nIf you have the option available, ensure to switch to GPU Compute instead of CPU when using the Cycles render engine. This will usually always be the better option, and the perforamnce will be much better.\n\nVideo"
  },
  {
    "objectID": "tutorials/00_interface.html#adding-objects",
    "href": "tutorials/00_interface.html#adding-objects",
    "title": "Blender’s Interface",
    "section": "Adding Objects",
    "text": "Adding Objects\nYou can add new objects by Shift + A or by using the Add menu in the top left.\nThere are a number of different object types that can be added. The most common that you will use will be Mesh and Light. Try adding some new objects, Grabbing them to move them around, Rotating them and Scaling them to different sizes. If you have just added a new object and it isn’t immediately visible, it might be inside another object, or it could be too big or too small to be immediately visible. Try moving the camera or the object around to get a better view.\n\n\n\nThe add menu. Also accesible through Shift + A\n\n\nVideo"
  },
  {
    "objectID": "tutorials/00_interface.html#rendering-an-image",
    "href": "tutorials/00_interface.html#rendering-an-image",
    "title": "Blender’s Interface",
    "section": "Rendering an Image",
    "text": "Rendering an Image\nTo render an image, you can click F12 or use the Render -&gt; Render Image menu. Blender will not render what you are immediately seeing. Instead, it will render whatever the Camera** is seeing. This can be frustrating at first, but it makes sense when you can have multiple cameras in a single scene.\nTo see what the camera sees, you can click the Camera widget in the top right, or click backtick (`) + 1.\n\nThe backtick is directly under the Esc key on most American / Enlgish keyboards. It can vary in other language layouts.\n\nVideo\nOnce you are happy with the camera framing, click render.\n\n\n\nThe render menu.\n\n\nA window should appear, showing the rendered image. Isn’t it magnificent?\nThe rendered image is not saved. You have to manually save the image by clicking Image -&gt; Save As and choose where to save the image.\n\n\n\nThe rendered image window."
  },
  {
    "objectID": "tutorials/00_interface.html#add-more-lights",
    "href": "tutorials/00_interface.html#add-more-lights",
    "title": "Blender’s Interface",
    "section": "Add More Lights",
    "text": "Add More Lights\nWe can make our 3D scene more interesting by adding more lights. When the light object is selected, the green Light Settings tab becomes available, appearing as a small green lightbulb. Under these settings, we can change the colour of our light, along with the Power. Try tweaking these settings to your liking. You can duplicate an object without adding a new one by clicking Shift + D.\n\n\nVideo\nAdding more lights to the scene."
  },
  {
    "objectID": "tutorials/00_interface.html#materials",
    "href": "tutorials/00_interface.html#materials",
    "title": "Blender’s Interface",
    "section": "Materials",
    "text": "Materials\nOne of the hardest things to get used to while working in 3D is the idea of materials. What if we want to make the monkey head Red? In 3D we can’t just make things red. Instead we have to assign it a material. This material can have the property that it is primarily red, but it is also metallic, has a sheen, reflects light, can be partially transparent as well as a whole range of other properties.\nComplex shading is an entire career itself, so we won’t get too much in to it. In this example we will just add a material to the monkey to make it red, and a different material to the cube to make it blue.\n\nIf you can’t see the colors changing, ensure you are in Rendered view.\n\nIn the example below, we create a new material called Material.001 for the monkey which we change to red. The cube already has a material called Material. We change the material being used to the monkey’s material, before changing it back and editing the starting material so that it is blue.\nTry playing around with some of the other material settings, to see what effects you can create.\n\n\nVideo\nAssigning materials to objects."
  },
  {
    "objectID": "tutorials/00_interface.html#edit-mode",
    "href": "tutorials/00_interface.html#edit-mode",
    "title": "Blender’s Interface",
    "section": "Edit Mode",
    "text": "Edit Mode\nThe last thing to be aware of when working inside of a 3D program like Blender, is that you can manually edit the 3D objects that are inside of the scene. In the top left hand corner of the 3D viewport. With an object selected, you can change between the different modes. You can edit the physical shape of a mesh, by moving individual or groups of vertices, by going into Edit Mode. You can also use the keyboard shortcut Tab\n\n\n\nThe different modes are available when an object is selected.\n\n\nWith a mesh object selected, you can change in to edit mode. While in edit mode, different options are available to you, and you can phsyically edit the mesh. Try selecting some vertices of the mesh and moving them around individually.\n\n\nVideo\nExample of entering edit mode.\n\n\nYou now know the very basics of adding new objects, changing the materials, adding some lights and rendering an image. The same principles apply to everything that you you do in Blender, and often all of the different workspaces will contain similar keyboard shortcuts and ways of working. Try playing around some more inside of the 3D scene, rendering some different 3D images, before moving on to the section which includes actual proteins.\nMost things are best learnt by doing, so load some proteins in and try to follow along with the other tutorials."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "About",
    "section": "",
    "text": "Molecular Nodes (MN) is an addon for the 3D modelling & animation program Blender. MN enables easy import of molecular data such as .pdb & .mmCIF, along with a variety of molecular dynamics trajectories and topologies from a variety of simulation sources. Other data formats including electron microscopy (EM) .map, EM tomography files such as .map and .star, with the potential to support more data formats as well.\nMolecular Nodes provides the translation layer that allows importing of molecular data formats, while Blender provides the industry-leading animation and rendering tools to create visually stunning molecular graphics with ease.\nThe add-on runs on the Geometry Nodes procedural modelling and animation system inside of Blender, which gives the add-on speed and robustness with minimal user input required."
  },
  {
    "objectID": "index.html#molecular-nodes-in-the-wild",
    "href": "index.html#molecular-nodes-in-the-wild",
    "title": "About",
    "section": "Molecular Nodes in the Wild",
    "text": "Molecular Nodes in the Wild\nBelow will feature some examples of Molecular Nodes being used in videos, from around the internet.\n\nVeritasium\n\n\n\n\nNano Rooms\n\n\n\n\n\nSt. Jude Children’s Research Hospital"
  },
  {
    "objectID": "index.html#getting-started",
    "href": "index.html#getting-started",
    "title": "About",
    "section": "Getting Started",
    "text": "Getting Started\nTo get started, checkout the installation page for detailed instructions on how to install the add-on. Next check out some of the tutorials, such as intro to blender, basics of downloading from the PDB or how to customise selections.\nThere are some slightly outdate tutorials on YouTube about how to use the add-on also. MN has been developed further and improved since these videos, but the general workflow remains the same."
  },
  {
    "objectID": "examples.html",
    "href": "examples.html",
    "title": "Examples",
    "section": "",
    "text": "To create the animation of ATP synthase you can morph between separate states of ATP synthase and export them from your favourite molecular graphics program. In this example, we will use ChimeraX.\nUse the following code in ChimeraX’s console to import and create a morph between the 3 different protein conformations that will create the animation:\nopen 6n2y 6n2z 6n30\nmorph #1,2,3 wrap true\nYou can now play back the animation inside of ChimeraX.\nTo save the animation as a multi-pdb file, use the following code to save the .pdb file:\nsave atp-frames.pdb #4 allCoordsets true\nYou can now open the multi-frame pdb file inside of Molecular Nodes using the ‘Open Local File’ tab.\n\nThis example is taken directly from the ChimeraX twitter account:\n\n\nTo morph between 3 conformations of ATP synthase use ChimeraX commands “open 6n2y 6n2z 6n30” and “morph #1,2,3 wrap true”. #ChimeraXHowTo pic.twitter.com/2u4Au6Tvpf\n\n— ChimeraX (@UCSFChimeraX) May 8, 2020"
  },
  {
    "objectID": "examples.html#animating-atp-synthase",
    "href": "examples.html#animating-atp-synthase",
    "title": "Examples",
    "section": "",
    "text": "To create the animation of ATP synthase you can morph between separate states of ATP synthase and export them from your favourite molecular graphics program. In this example, we will use ChimeraX.\nUse the following code in ChimeraX’s console to import and create a morph between the 3 different protein conformations that will create the animation:\nopen 6n2y 6n2z 6n30\nmorph #1,2,3 wrap true\nYou can now play back the animation inside of ChimeraX.\nTo save the animation as a multi-pdb file, use the following code to save the .pdb file:\nsave atp-frames.pdb #4 allCoordsets true\nYou can now open the multi-frame pdb file inside of Molecular Nodes using the ‘Open Local File’ tab.\n\nThis example is taken directly from the ChimeraX twitter account:\n\n\nTo morph between 3 conformations of ATP synthase use ChimeraX commands “open 6n2y 6n2z 6n30” and “morph #1,2,3 wrap true”. #ChimeraXHowTo pic.twitter.com/2u4Au6Tvpf\n\n— ChimeraX (@UCSFChimeraX) May 8, 2020"
  },
  {
    "objectID": "examples.html#animating-covid-spike-protein",
    "href": "examples.html#animating-covid-spike-protein",
    "title": "Examples",
    "section": "2 Animating COVID Spike Protein",
    "text": "2 Animating COVID Spike Protein\n\n\n\n\n\n\nRequires MDAnalysis Installed\n\n\n\nTo follow this particular tutorial, ensure you have first installed Molecular Nodes properly, including the optional MDAnalysis python package.\n\n\nDownload the trajectory files from the the CHARMM-GUI website:\nYou will want to download the .xtc files for the spike protein in membrane.\n\n\n\n\n\n\nCaution\n\n\n\nThe .xtc file will be large, ~2GB so the download may take a while.\n\n\n\nUnzip the files (you may need to unzip the unzipped file) and then inside of Molecular Nodes, in the MD Trajectory tab, select the tpology file (last_frame_nos.pdb) and the trajectory file (trj_nos.xtc).\n\nGive the molecule a name, and your panel should look like this:\n\n\n2.1 Frames to Import\nIn the frame import options, we can choose which frames from the trajectory to import. Importing every frame (interval = 1 ) will take long time to load, and balloon-out the save-file size of the .blend file. It’s best to work with some subset of the trajectory frames, and interpolate between them with Molecular Nodes.\n\n\n\n\n\n\n\nNote\n\n\n\nMolecular nodes is still surprisingly performant with thousands of frames loaded, but the .blend file takes a long time to save and load due to several GBs worth of data being save and loaded each time.\n\n\nFor this example we are going to import every 10th frame.\n\n\n2.2 Click ‘Import Frames’ and Wait\nMolecular Nodes is working through a lot of data, so this load step can take a few minutes - be patient. Once it’s all loaded, the structure along with the atomic properties are available for use inside of Geometry Nodes!\n\n\n2.3 Click space to play the animation.\nEnsure to change over to Cycles & rendered view to view the coloured atoms, but otherwise the animation should be playing if press space!\nJust Points\nVideo\nRendered View In this scene I additionally added a Sun light.\nVideo\n\n\n2.4 Geometry Nodes\nNow that the animation is imported into geometry nodes, you can work with the points as you would otherwise.\nTry applying some noise, or in this example, scaling the points to 0 based on the proximity to an empty.\nVideo"
  },
  {
    "objectID": "nodes.html",
    "href": "nodes.html",
    "title": "Nodes",
    "section": "",
    "text": "The nodes that you work with inside of Molecular Nodes are pre-defined in a MN_data_file.blend file that is included with the add-on. When a node is added, it is appended to the current file to be used by you. If you wish to change how a node behaves, you can Tab into the node group to change the internals, and Ctrl + Tab to leave the node group.\nThe nodes are shared between node trees, so if you change the internals of the ‘Cartoon’ node then this will change how it works for every node tree in your .blend file. If you wish to create changes that are only for a single node tree, you can create a copy of it first before making changes by doing the following:"
  },
  {
    "objectID": "nodes.html#animate",
    "href": "nodes.html#animate",
    "title": "Nodes",
    "section": "Animate",
    "text": "Animate\n\nAnimate Frames\nAnimate the atoms of a structure, based on the frames of a trajectory from the Frames collection in the input. The structure animates through the trajectory from the given start frame to the given end frame, as the Animate 0..1 value moves from 0 to 1. Values higher than 1 start at the beginning again and the trajectory will loop repeating every 1.00. Position and b_factor are interpolated if available. By default linear interpolation is used. Smoothing in and out of each frame can be applied with the Smoother Step, or no interpolation at all.\nVideo\n\nInputs\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nAtoms\nGeometry\nAtomic geometry that contains vertices and edges.\nrequired\n\n\nSelection\nBoolean\nWhether to animate the given atoms\nTrue\n\n\nIndex\nInteger\nThe index to use when sampling the trajectory\n0\n\n\nFrames\nCollection\nCollection which holds the frames of the trajectory\nrequired\n\n\nStart\nInteger\nFrame to start the trajectory interpolation from\n0\n\n\nEnd\nInteger\nFrame to finish trajectory interpolation from (-1 is the last)\n-1\n\n\nInterpolate\nBoolean\nWhether to interpolate between frames of a trajectory or snap\nTrue\n\n\nSmoother Step\nBoolean\nEase in and out of the individual frames if interpolating\nFalse\n\n\nAnimate 0..1\nFloat (Factor)\nAnimate through the trajectory, 0 -&gt; 1, frames Start -&gt; End\n0.0\n\n\n\n\n\nOutputs\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nAtoms\nGeometry\nAtomic geometry with new positions based on the trajectory\nrequired\n\n\nInterpolated\nBoolean\nWhether or not the atoms are being interpolated\nFalse\n\n\n\n\n\n\nAnimate Noise Field\nCreate a 3D noise vector based on the input field. Evolve the noise function with the Animate input, and change the characteristics of the noise function with the other inputs such as scale and detail. There is also a 1-dimensional noise output called Fac.\nAn example of using this noise is to offset the positions of atoms with the Set Position node. Different field inputs result in different noise being applied. Using the chain_id results in the same noise being generated for each atom in each chain, but different between chains.\nVideo\n\nInputs\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nField\nVector\n\n[0.0, 0.0, 0.0]\n\n\nAmplitude\nFloat\n\n0.25\n\n\nAnimate\nFloat\n\n0.0\n\n\nScale\nFloat\n\n1.0\n\n\nDetail\nFloat\n\n3.0\n\n\nRoughness\nFloat (Factor)\n\n1.0\n\n\nDistortion\nFloat\n\n0.0\n\n\n\n\n\nOutputs\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nNoise\nVector\n\n[0.0, 0.0, 0.0]\n\n\nFac\nFloat\n\n0.0\n\n\n\n\n\n\nAnimate Noise Position\nCreate 3D noise vector based on the position of points in 3D space. Evolve the noise function with the Animate input, and change the characteristics of the noise function with the other inputs such as scale and detail. There is also a 1-dimensional noise output called Fac.\nAn example of using this noise is to offset the positions of atoms with the Set Position node.\nVideo\n\nInputs\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nAmplitude\nFloat\n\n0.25\n\n\nAnimate\nFloat\n\n0.0\n\n\nScale\nFloat\n\n1.0\n\n\nDetail\nFloat\n\n3.0\n\n\nRoughness\nFloat (Factor)\n\n1.0\n\n\nDistortion\nFloat\n\n0.0\n\n\n\n\n\nOutputs\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nVector\nVector\n\n[0.0, 0.0, 0.0]\n\n\nFac\nFloat\n\n0.0\n\n\n\n\n\n\nAnimate Noise Repeat\nCreate a 3D noise vector based on the input field, that repeats every 1.00 for the Animate 0..1 input. Evolve the noise function with the Animate input, and change the characteristics of the noise function with the other inputs such as scale and detail. There is also a 1-dimensional noise output called Fac.\nAn example of using this noise is to offset the positions of atoms with the Set Position node. Different field inputs result in different noise being applied. Using the chain_id results in the same noise being generated for each atom in each chain, but different between chains.\nVideo\n\nInputs\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nAmplitude\nFloat\n\n1.0\n\n\nDetail\nFloat\n\n0.5\n\n\nRoughness\nFloat (Factor)\n\n0.5\n\n\nDistortion\nFloat\n\n0.0\n\n\nVector\nVector\n\n[0.0, 0.0, 0.0]\n\n\nSpeed\nFloat\n\n0.5\n\n\nAnimate 0..1\nFloat\n\n0.5\n\n\n\n\n\nOutputs\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nNoise Float\nFloat\n\n0.0\n\n\nNoise Vector\nVector\n\n[0.0, 0.0, 0.0]\n\n\n\n\n\n\nAnimate Res To Curve\nTake the protein residues from a structure and align then along an input curve. Editing the curve will change how the atoms are arranged. The output atoms can be styled as normal.\nVideo\n\nInputs\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nAtoms\nGeometry\nAtomic geometry that contains vertices and edges.\nrequired\n\n\nCurve\nGeometry\n\nrequired\n\n\nOffset\nFloat\n\n0.0\n\n\nStart\nFloat (Factor)\n\n0.0\n\n\nEnd\nFloat (Factor)\n\n1.0\n\n\nRotate\nFloat\n\n0.5\n\n\nTwist\nFloat\n\n1.0\n\n\n\n\n\nOutputs\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nAtoms\nGeometry\n\nrequired\n\n\n\n\n\n\nAnimate Res Wiggle\nCreate a procedural animation of side-chain movement. ‘Wiggles’ the side-chains of peptide amino acids based on the b_factor attribute. Wiggle is currently only supported for protein side-chains and does not check for steric clashing so higher amplitudes will result in strange results. The animation should seamlessly loop every 1.00 of the Animate 0..1 input.\nVideo\n\nInputs\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nAtoms\nGeometry\nAtomic geometry that contains vertices and edges.\nrequired\n\n\nSelection\nBoolean\nAtoms to apply the wiggle animaton to\nTrue\n\n\nb_factor: Scale\nFloat (Factor)\nAmount that b_factor changeds the amplitude of wiggling\n1.0\n\n\nAmplitude\nFloat\nOverall amplitude of the wiggling\n1.0\n\n\nAmp. Axis\nFloat\nAplitude for the rotation around the bond axes\n1.0\n\n\nAmp. Euler\nFloat\nAmplitude for applying euler rotations separate to the axis\n0.4\n\n\nSpeed\nFloat\nSpeed at which the wiggle is applied, 3 will repeat 3 times\n3.0\n\n\nAnimate 0..1\nFloat\nControls the animation of the wiggle, repeating every 1.00\n0.0\n\n\n\n\n\nOutputs\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nAtoms\nGeometry\nThe animated atomic geometry\nrequired\n\n\n\n\n\n\nAnimate Value\nAnimate a float value between the specified min and max values, over specified range of frames. If clamped, frames above and below the start and end will result in the min and max output values, otherwise it will continue to linearly interpolate the value beyond the min and max values.\nVideo\n\nInputs\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nFrame: Start\nInteger\nFrame to start the animation on\n1\n\n\nFrame: End\nInteger\nFrame to finish the animation on\n250\n\n\nSmoother Step\nBoolean\nEase out and in from the min and max values\nFalse\n\n\nClamped\nBoolean\nWhether to clamp the interpolated value to the max\nFalse\n\n\nTo Min\nFloat\nValue to start animation from\n0.0\n\n\nTo Max\nFloat\nValue to end animation at\n1.0\n\n\n\n\n\nOutputs\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nValue\nFloat\nAnimated value that interpolates from min to max over frames\n0.0"
  },
  {
    "objectID": "nodes.html#assembly",
    "href": "nodes.html#assembly",
    "title": "Nodes",
    "section": "Assembly",
    "text": "Assembly\n\nAssembly\nCreates a biological assembly by applying rotation and translation matrices to individual chains in the structure. It is created on an individual molecule basis, if assembly instructions are detected when imported.\nVideo\n\nInputs\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nGeometry\nGeometry\nAny geometry to separate into chains and instance\nrequired\n\n\nRotation\nFloat (Factor)\nAmount to apply the rotation of the matrix\n1.0\n\n\nTranslation\nFloat (Factor)\nAmount to apply the translation of the matrix\n1.0\n\n\nassembly_id\nInteger\nWhich biological assembly to create\n1\n\n\n\n\n\nOutputs\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nAssembled Chain Instances\nGeometry\n\nrequired\n\n\n\n\n\n\nAssembly Center\nMove an instanced assembly to the world origin. Some structures are not centred on the world origin, so this node can reset them to the world origin for convenient rotation and translation and animation.\nVideo\n\nInputs\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nAssembly Instances\nGeometry\nThe instances of an assembly, the result of MN_assembly\nrequired\n\n\nCenter\nBoolean\nWhether to center the assembly\nTrue\n\n\nTranslation\nVector (Translation)\nAdditional translation to apply to the centered assembly\n[0.0, 0.0, 0.0]\n\n\n\n\n\nOutputs\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nAssembly Instances\nGeometry\nThe translated assembly\nrequired\n\n\nOld Centre\nVector\nThe old centre point of the assembly\n[0.0, 0.0, 0.0]\n\n\nTransform Vector\nVector\nThe transformation that was applied to the assembly\n[0.0, 0.0, 0.0]"
  },
  {
    "objectID": "nodes.html#color",
    "href": "nodes.html#color",
    "title": "Nodes",
    "section": "Color",
    "text": "Color\n\nColor Atomic Number\nChoose a color for an individual element. Select the element based on atomic_number. Useful for higher atomic number elements which are less commonly found in structures.\nVideo\n\nInputs\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\natomic_number\nInteger\n\n6\n\n\nColor\nColor\n\nrgb(204, 204, 204)◉\n\n\n\n\n\nOutputs\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nColor\nColor\n\nrgb(0, 0, 0)◉\n\n\n\n\n\n\nColor Attribute Map\nInterpolate between two or three colors, based on the value of an attribute field such as b_factor. Choosing the minimum and maximum values with the inputs.\nVideo\n\nInputs\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nMid Color\nBoolean\nWheter to interpolate through the ‘Mid’ color.\nTrue\n\n\nMin\nColor\nColor for the minimum value of the attribute\nrgb(19, 122, 127)◉\n\n\nMid\nColor\nColor for the median value of the attribute\nrgb(127, 127, 127)◉\n\n\nMax\nColor\nColor for the maximum value of the attribute\nrgb(127, 40, 14)◉\n\n\nFrom Min\nFloat\nInterpolate colors from this minimum value of the attribute\n0.0\n\n\nFrom Max\nFloat\nInterpolate colors from this maximum value of the attribute\n150.0\n\n\n\n\n\nOutputs\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nResult\nColor\nThe mapped color value based on the attribute.\nrgb(0, 0, 0)◉\n\n\n\n\n\n\nColor Attribute Random\nGenerate a random color, based on the given attribute. Control the lightness and saturation of the color with the inputs.\nVideo\n\nInputs\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nSaturation\nFloat (Factor)\nSaturlation level for the random color\n0.6\n\n\nLightness\nFloat (Factor)\nLightness value for the generated random color\n0.6\n\n\nSeed\nInteger\nSeed value for the random generation of the colors\n0\n\n\n\n\n\nOutputs\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nColor\nColor\nThe randomly generated color based on the input attribute\nrgb(0, 0, 0)◉\n\n\n\n\n\n\nColor Chain\nChoose the colors for individual chains in the structure. This node is generated for each particular molecule, so the inputs will look different based on the imported structure. For larger structures with many chains this node may become too large to be practical, in which case you might better use MN_color_entity_id.\nVideo\n\nInputs\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nChain A\nColor\nColor to set for Chain A\nrgb(117, 153, 61)◉\n\n\nChain B\nColor\nColor to set for Chain B\nrgb(61, 153, 146)◉\n\n\n...\nColor\nColor to set for Chain …\nrgb(153, 61, 118)◉\n\n\n\n\n\nOutputs\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nColor\nColor\nThe colors based on chain_id\nrgb(0, 0, 0)◉\n\n\n\n\n\n\nColor Common\nChoose a color for each of the common elements. This is a smaller convenience node for elements which commonly appear in macromolecular structures. Use MN_color_element for the first 20 elements and MN_color_atomic_number for individual elements with higher atomic numbers.\nVideo\n\nInputs\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nHydrogen\nColor\nColor to set for the element Hydrogen\nrgb(255, 255, 255)◉\n\n\nCarbon\nColor\nColor to set for the element Carbon\nrgb(51, 51, 51)◉\n\n\nNitrogen\nColor\nColor to set for the element Nitrogen\nrgb(40, 59, 204)◉\n\n\nOxygen\nColor\nColor to set for the element Oxygen\nrgb(204, 41, 40)◉\n\n\nPhosphorous\nColor\nColor to set for the element Phosphorous\nrgb(204, 43, 133)◉\n\n\nSulfur\nColor\nColor to set for the element Sulfur\nrgb(204, 184, 13)◉\n\n\n\n\n\nOutputs\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nColor\nColor\nThe output colors for the common elements\nrgb(0, 0, 0)◉\n\n\n\n\n\n\nColor Element\nChoose a color for each of the first 20 elements on the periodic table. For higher atomic number elements use MN_color_atomic_number.\nVideo\n\nInputs\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nHydrogen\nColor\nColor to set for the element Hydrogen\nrgb(255, 255, 255)◉\n\n\nHelium\nColor\nColor to set for the element Helium\nrgb(24, 24, 24)◉\n\n\nLithium\nColor\nColor to set for the element Lithium\nrgb(29, 56, 47)◉\n\n\nBerylium\nColor\nColor to set for the element Berylium\nrgb(35, 86, 109)◉\n\n\nBoron\nColor\nColor to set for the element Boron\nrgb(71, 38, 26)◉\n\n\nCarbon\nColor\nColor to set for the element Carbon\nrgb(51, 51, 51)◉\n\n\nNitrogen\nColor\nColor to set for the element Nitrogen\nrgb(32, 52, 204)◉\n\n\nOxygen\nColor\nColor to set for the element Oxygen\nrgb(204, 17, 17)◉\n\n\nFluorine\nColor\nColor to set for the element Fluorine\nrgb(46, 194, 86)◉\n\n\nNeon\nColor\nColor to set for the element Neon\nrgb(23, 159, 33)◉\n\n\nSodium\nColor\nColor to set for the element Sodium\nrgb(9, 43, 104)◉\n\n\nMagnesium\nColor\nColor to set for the element Magnesium\nrgb(13, 13, 13)◉\n\n\nAluminium\nColor\nColor to set for the element Aluminium\nrgb(134, 115, 126)◉\n\n\nSilicon\nColor\nColor to set for the element Silicon\nrgb(91, 77, 24)◉\n\n\nPhosphorous\nColor\nColor to set for the element Phosphorous\nrgb(204, 43, 133)◉\n\n\nSulfur\nColor\nColor to set for the element Sulfur\nrgb(204, 184, 13)◉\n\n\nChlroine\nColor\nColor to set for the element Chlroine\nrgb(27, 255, 29)◉\n\n\nArgon\nColor\nColor to set for the element Argon\nrgb(134, 34, 104)◉\n\n\nPotassium\nColor\nColor to set for the element Potassium\nrgb(21, 93, 162)◉\n\n\nCalcium\nColor\nColor to set for the element Calcium\nrgb(17, 38, 142)◉\n\n\n\n\n\nOutputs\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nColor\nColor\n\nrgb(0, 0, 0)◉\n\n\n\n\n\n\nColor Entity\nChoose the colors for individual entities in the structure. Multiple chains may be classified as the same entity, if they are copies of the same chain but in different conformations or positions and rotations. The nodes is generated for each individual structure, if entity_id is available.\nVideo\n\nInputs\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nEntity A\nColor\nColor to set for Entity B\nrgb(117, 153, 61)◉\n\n\nEntity B\nColor\nColor to set for Entity B\nrgb(61, 153, 146)◉\n\n\n...\nColor\nColor to set for Entity …\nrgb(153, 61, 118)◉\n\n\n\n\n\nOutputs\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nColor\nColor\nThe colors based on entity_id\nrgb(0, 0, 0)◉\n\n\n\n\n\n\nColor Goodsell\nChange the inputted color to be darker for non-carbon atoms. Creates a Goodsell Style color scheme for individual chains.\nVideo\n\nInputs\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nInvert\nBoolean\nWhether to invert the darkening of the colors\nFalse\n\n\nFactor\nFloat (Factor)\nAmount to apply the ‘Goodsell Style’ coloring to\n0.5\n\n\nColor\nColor\nColor to apply ‘Goodsell’ style colors to\nrgb(127, 127, 127)◉\n\n\n\n\n\nOutputs\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nColor\nColor\n\nrgb(0, 0, 0)◉\n\n\n\n\n\n\nColor Ligand\nChange the inputted color to be darker for non-carbon atoms. Creates a Goodsell Style color scheme for individual chains.\nVideo\n\nInputs\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nLigand A\nColor\nColor to set for Ligand B\nrgb(117, 153, 61)◉\n\n\nLigand B\nColor\nColor to set for Ligand B\nrgb(61, 153, 146)◉\n\n\n...\nColor\nColor to set for Ligand …\nrgb(153, 61, 118)◉\n\n\n\n\n\nOutputs\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nColor\nColor\nThe colors based on entity_id\nrgb(0, 0, 0)◉\n\n\n\n\n\n\nColor Res Name Nucleic\nChoose a color for each of the nucleic acids. Non nucleic acid atoms will retain their currently set color.\nVideo\n\nInputs\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nA\nColor\n\nrgb(70, 139, 203)◉\n\n\nC\nColor\n\nrgb(75, 204, 47)◉\n\n\nG\nColor\n\nrgb(204, 60, 42)◉\n\n\nT / U\nColor\n\nrgb(204, 68, 134)◉\n\n\n\n\n\nOutputs\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nColor\nColor\n\nrgb(0, 0, 0)◉\n\n\n\n\n\n\nColor Res Name Peptide\nChoose a color for each of the 20 naturally occurring amino acids. Non AA atoms will retain their currently set color.\nVideo\n\nInputs\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nALA\nColor\nColor to set the atoms in AA ALA\nrgb(214, 91, 184)◉\n\n\nARG\nColor\nColor to set the atoms in AA ARG\nrgb(92, 91, 214)◉\n\n\nASN\nColor\nColor to set the atoms in AA ASN\nrgb(91, 208, 214)◉\n\n\nASP\nColor\nColor to set the atoms in AA ASP\nrgb(91, 163, 214)◉\n\n\nCYS\nColor\nColor to set the atoms in AA CYS\nrgb(91, 214, 179)◉\n\n\nGLU\nColor\nColor to set the atoms in AA GLU\nrgb(91, 214, 125)◉\n\n\nGLN\nColor\nColor to set the atoms in AA GLN\nrgb(138, 91, 214)◉\n\n\nGLY\nColor\nColor to set the atoms in AA GLY\nrgb(151, 91, 214)◉\n\n\nHIS\nColor\nColor to set the atoms in AA HIS\nrgb(137, 214, 91)◉\n\n\nILE\nColor\nColor to set the atoms in AA ILE\nrgb(214, 204, 91)◉\n\n\nLEU\nColor\nColor to set the atoms in AA LEU\nrgb(173, 214, 91)◉\n\n\nLYS\nColor\nColor to set the atoms in AA LYS\nrgb(214, 91, 113)◉\n\n\nMET\nColor\nColor to set the atoms in AA MET\nrgb(91, 214, 209)◉\n\n\nPHE\nColor\nColor to set the atoms in AA PHE\nrgb(214, 91, 161)◉\n\n\nPRO\nColor\nColor to set the atoms in AA PRO\nrgb(138, 214, 91)◉\n\n\nSER\nColor\nColor to set the atoms in AA SER\nrgb(91, 214, 198)◉\n\n\nTHR\nColor\nColor to set the atoms in AA THR\nrgb(214, 205, 91)◉\n\n\nTRP\nColor\nColor to set the atoms in AA TRP\nrgb(91, 183, 214)◉\n\n\nTYR\nColor\nColor to set the atoms in AA TYR\nrgb(214, 114, 91)◉\n\n\nVAL\nColor\nColor to set the atoms in AA VAL\nrgb(214, 179, 91)◉\n\n\n\n\n\nOutputs\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nColor\nColor\nColor based on the res_name attribute\nrgb(0, 0, 0)◉\n\n\n\n\n\n\nColor Sec Struct\nChoose a color for the different secondary structures, based on the sec_struct attribute.\nVideo\n\nInputs\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nAlpha Helix\nColor\nColor to set for alpha helices\nrgb(41, 159, 49)◉\n\n\nBeta Sheet\nColor\nColor to set for beta-sheets\nrgb(255, 38, 38)◉\n\n\nLoop\nColor\nColor to set for loops\nrgb(43, 93, 203)◉\n\n\n\n\n\nOutputs\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nColor\nColor\nThe colors based on secondary structure\nrgb(0, 0, 0)◉\n\n\n\n\n\n\nColor Set\nThe is the primary way to change the color of structures in Molecular Nodes. Colors for cartoon and ribbon are taken from the alpha-carbons of the structures. Change the color of the input atoms, based on a selection and a color field. The color field can be as complex of a calculation as you wish. In the example below the color for the whole structure can be set, or the color can be based on a color for each chain, or the result of mapping a color to an attribute such as b_factor.\nVideo\n\nInputs\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nAtoms\nGeometry\nAtomic geometry that contains vertices and edges.\nrequired\n\n\nSelection\nBoolean\nSelection to update the assigned color for\nTrue\n\n\nColor\nColor\nColor to apply to the selected atoms\nrgb(41, 159, 49)◉\n\n\n\n\n\nOutputs\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nAtoms\nGeometry\nAtomic geometry with an updated Color attribute\nrequired"
  },
  {
    "objectID": "nodes.html#density",
    "href": "nodes.html#density",
    "title": "Nodes",
    "section": "Density",
    "text": "Density\n\nDensity Sample Nearest\nSample the nearest atoms from another object, to get the colors or other attributes and apply them to a volume mesh.\nVideo\n\nInputs\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nAtoms\nGeometry\nAtomic geometry that contains vertices and edges.\nrequired\n\n\n\n\n\nOutputs\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nColor\nColor\n\nrgb(0, 0, 0)◉\n\n\nb_factor\nFloat\n\n0.0\n\n\natomic_number\nInteger\n\n0\n\n\nchain_number\nInteger\n\n0\n\n\nres_id\nInteger\n\n0\n\n\nres_name\nInteger\n\n0\n\n\n\n\n\n\nDensity Style Surface\nA surface made from the electron density given a certain threshold value.\nVideo\n\nInputs\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nVolume\nGeometry\n\nrequired\n\n\nDensity Threshold\nFloat\n\n0.8\n\n\nColor\nColor\n\nrgb(50, 129, 33)◉\n\n\nMaterial\nMaterial\n\nMN_atomic_style\n\n\n\n\n\nOutputs\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nGeometry\nGeometry\n\nrequired\n\n\n\n\n\n\nDensity Style Wire\nA wire surface made from the electron density given a certain threshold value.\nVideo\n\nInputs\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nVolume\nGeometry\n\nrequired\n\n\nDensity Threshold\nFloat\n\n0.8\n\n\nColor\nColor\n\nrgb(25, 100, 26)◉\n\n\nWire Radius\nFloat (Distance)\n\n0.1\n\n\nWire Resolution\nInteger\n\n3\n\n\nMaterial\nMaterial\n\nMN_atomic_style\n\n\n\n\n\nOutputs\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nGeometry\nGeometry\n\nrequired"
  },
  {
    "objectID": "nodes.html#select",
    "href": "nodes.html#select",
    "title": "Nodes",
    "section": "Select",
    "text": "Select\n\nSelect Atomic Number\nSelect single elements, by matching to the atomic_number field. Useful for selecting single elements, or combining to select elements higher than 20 on the periodic table.\nVideo\n\nInputs\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\natomic_number\nInteger\nCreate a selection based on the inputted atomic number.\n6\n\n\n\n\n\nOutputs\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nSelection\nBoolean\nThe calculated selection\nFalse\n\n\nInverted\nBoolean\nThe inverse of the calculated selection\nFalse\n\n\n\n\n\n\nSelect Attribute\nSelections based on the different attributes that are available on the atomic geometry.\nVideo\n\nOutputs\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nis_alpha_carbon\nBoolean\n\nFalse\n\n\nis_backbone\nBoolean\n\nFalse\n\n\nis_peptide\nBoolean\n\nFalse\n\n\nis_nucleic\nBoolean\n\nFalse\n\n\nis_carb\nBoolean\n\nFalse\n\n\nis_solvent\nBoolean\n\nFalse\n\n\n\n\n\n\nSelect Backbone\nSelection fields for the backbone and side chains of the protein and nucleic acids.\nVideo\n\nOutputs\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nis_alpha_carbon\nBoolean\n\nFalse\n\n\nis_backbone\nBoolean\n\nFalse\n\n\nis_side_chain\nBoolean\n\nFalse\n\n\n\n\n\n\nSelect Bonded\nBased on an initial selection, finds atoms which are within a certain number of bonds of this selection. Output can include or excluded the original selection.\nVideo\n\nInputs\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nSelection\nBoolean\nInitial selection to find which atoms are bonded to\nFalse\n\n\nBond Depth\nInteger\nNumber of bonds to expand the selection by\n2\n\n\n\n\n\nOutputs\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nBonded + Selection\nBoolean\nExpanded selection that includes the original selection\nFalse\n\n\nBonded\nBoolean\nExpanded Selection that excludes the original selection\nFalse\n\n\n\n\n\n\nSelect Chain\nSelect single or multiple of the different chains. Creates a selection based on the chain_id attribute.\nVideo\n\nInputs\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nChain A\nBoolean\nSelect the atoms in Chain A\nTrue\n\n\nChain B\nBoolean\nSelect the atoms in Chain B\nTrue\n\n\nChain ...\nBoolean\nSelect the atoms in Chain …\nTrue\n\n\n\n\n\nOutputs\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nSelection\nBoolean\nThe calculated selection\nFalse\n\n\nInverted\nBoolean\nThe inverse of the calculated selection\nFalse\n\n\n\n\n\n\nSelect Cube\nCreate a selection that is inside the Empty_Cube object. When this node is first created, an empty object called Empty_Cube should be created. You can always create additional empty objects through the add menu, to use a different object. The rotation and scale of the object will be taken into account for the selection.\nVideo\n\nInputs\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nObject\nObject\nEmpty object (ideally Cube) to use as the selection tool.\nrequired\n\n\nFrom Min (A)\nFloat\nMinimum distance for falloff, in Angstroms.\n0.0\n\n\nFrom Max (A)\nFloat\nMaximum distance for falloff, in Angstroms.\n10.0\n\n\n\n\n\nOutputs\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nSelection\nBoolean\nThe calculated selection\nFalse\n\n\nInverted\nBoolean\nThe inverse of the calculated selection\nFalse\n\n\n0..1\nFloat\nFalloff value from 0 to 1, based on the From Min and From Max.\n0.0\n\n\n\n\n\n\nSelect Distance Empty\nCreate a selection that is inside the Empty_Cube object. When this node is first created, an empty object called Empty_Cube should be created. You can always create additional empty objects through the add menu, to use a different object. The rotation and scale of the object will be taken into account for the selection.\nVideo\n\nInputs\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nObject\nObject\n\nrequired\n\n\nFrom Min\nFloat\n\n0.0\n\n\nFrom Max\nFloat\n\n1.0\n\n\nDistance\nFloat\n\n3.0\n\n\n\n\n\nOutputs\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\n&gt; Cutoff\nBoolean\n\nFalse\n\n\n&lt; Cutoff\nBoolean\n\nFalse\n\n\nDistance\nFloat\n\n0.0\n\n\n0..1\nFloat\n\n0.0\n\n\n\n\n\n\nSelect Element\nSelect individual elements, for the first 20 elements on the periodic table. For selections of higher elements, use MN_select_atomic_number. Creating a node which includes more elements becomes too large to be practical.\nVideo\n\nInputs\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nH\nBoolean\nSelect the element H\nFalse\n\n\nHe\nBoolean\nSelect the element He\nFalse\n\n\nLi\nBoolean\nSelect the element Li\nFalse\n\n\nBe\nBoolean\nSelect the element Be\nFalse\n\n\nB\nBoolean\nSelect the element B\nFalse\n\n\nC\nBoolean\nSelect the element C\nFalse\n\n\nN\nBoolean\nSelect the element N\nFalse\n\n\nO\nBoolean\nSelect the element O\nFalse\n\n\nF\nBoolean\nSelect the element F\nFalse\n\n\nNe\nBoolean\nSelect the element Ne\nFalse\n\n\nNa\nBoolean\nSelect the element Na\nFalse\n\n\nMg\nBoolean\nSelect the element Mg\nFalse\n\n\nAl\nBoolean\nSelect the element Al\nFalse\n\n\nSi\nBoolean\nSelect the element Si\nFalse\n\n\nP\nBoolean\nSelect the element P\nFalse\n\n\nS\nBoolean\nSelect the element S\nFalse\n\n\nCl\nBoolean\nSelect the element Cl\nFalse\n\n\nAr\nBoolean\nSelect the element Ar\nFalse\n\n\nK\nBoolean\nSelect the element K\nFalse\n\n\nCa\nBoolean\nSelect the element Ca\nFalse\n\n\n\n\n\nOutputs\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nSelection\nBoolean\nThe calculated selection\nFalse\n\n\nInverted\nBoolean\nThe inverse of the calculated selection\nFalse\n\n\n\n\n\n\nSelect Entity\nSelect single or multiple of the different entities. Creates a selection based on the entity_id attribute.\nVideo\n\nInputs\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nEntity A\nBoolean\nSelect the atoms in Entity A\nTrue\n\n\nEntity B\nBoolean\nSelect the atoms in Entity B\nTrue\n\n\nEntity ...\nBoolean\nSelect the atoms in Entity …\nTrue\n\n\n\n\n\nOutputs\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nSelection\nBoolean\nThe calculated selection\nFalse\n\n\nInverted\nBoolean\nThe inverse of the calculated selection\nFalse\n\n\n\n\n\n\nSelect Ligand\nSelect single or multiple of the different ligands.\nVideo\n\nInputs\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nLigand A\nBoolean\nSelect the atoms in Ligand A\nTrue\n\n\nLigand B\nBoolean\nSelect the atoms in Ligand B\nTrue\n\n\nLigand ...\nBoolean\nSelect the atoms in Ligand …\nTrue\n\n\n\n\n\nOutputs\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nSelection\nBoolean\nThe calculated selection\nFalse\n\n\nInverted\nBoolean\nThe inverse of the calculated selection\nFalse\n\n\n\n\n\n\nSelect Proximity\nCreate a selection based on the proximity to the Target Atoms of the input. A sub-selection of the Target atoms can be used if the Selection input is used. You can expand the selection to include an entire residue if a single atom in that residue is selected, by setting Whole Residue to True. In the example below, the MN_style_atoms is being applied to a selection, which is being calculated from the proximity of atoms to specific chains. As the cutoff for the selection is changed, it includes or excludes more atoms. The Whole Residue option also ensures that entire residues are shown.\nVideo\n\nInputs\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nTarget Atoms\nGeometry\nThe atoms to measure the distance from.\nrequired\n\n\nSelection\nBoolean\nAdditional selection to apply to the target atoms\nTrue\n\n\nWhole Residue\nBoolean\nExpand selection to entire residue if single atom is selected\nFalse\n\n\nDistance (A)\nFloat\nCutoff distance for the selection in Angrstoms\n5.0\n\n\n\n\n\nOutputs\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nSelection\nBoolean\nThe calculated selection\nFalse\n\n\nInverted\nBoolean\nThe inverse of the calculated selection\nFalse\n\n\n\n\n\n\nSelect Res Id\nCreate a more complex selection for the res_id field, by specifying multiple ranges and potential single res_id numbers. This node is built uniquely each time, to the inputs will look different for each user. In the example below, residues 10 & 15 are selected, as well as residues between and including 20-100. The node was created by inputting 10, 15, 20-100 into the node creation field.\nVideo\n\nInputs\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nres_id\nInteger\nA single res_id selection\n10\n\n\nres_id\nInteger\nA single res_id selection\n15\n\n\nres_id: Min\nInteger\nMinimum of a res_id range selection\n20\n\n\nres_id: Max\nInteger\nMaximum of a res_id range selection\n100\n\n\n\n\n\nOutputs\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nSelection\nBoolean\nThe calculated selection\nFalse\n\n\nInverted\nBoolean\nThe inverse of the calculated selection\nFalse\n\n\n\n\n\n\nSelect Res Id Range\nSelect multiple residues by specifying a minimum and a maximum which will create the selection based on the res_id number.\nVideo\n\nInputs\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nres_id: Min\nInteger\nMinimum of a res_id range selection\n10\n\n\nres_id: Max\nInteger\nMaximum of a res_id range selection\n100\n\n\n\n\n\nOutputs\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nSelection\nBoolean\nThe calculated selection\nFalse\n\n\nInverted\nBoolean\nThe inverse of the calculated selection\nFalse\n\n\n\n\n\n\nSelect Res Id Single\nSelect a single residue based on the res_id number.\nVideo\n\nInputs\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nres_id\nInteger\nA single res_id selection\n10\n\n\n\n\n\nOutputs\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nSelection\nBoolean\nThe calculated selection\nFalse\n\n\nInverted\nBoolean\nThe inverse of the calculated selection\nFalse\n\n\n\n\n\n\nSelect Res Name Nucleic\nSelect single or multiple nucleic residues by name.\nVideo\n\nInputs\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nA\nBoolean\nSelect the nucleic residue A\nTrue\n\n\nC\nBoolean\nSelect the nucleic residue C\nTrue\n\n\nG\nBoolean\nSelect the nucleic residue G\nTrue\n\n\nT\nBoolean\nSelect the nucleic residue T\nTrue\n\n\nrA\nBoolean\nSelect the nucleic residue rA\nTrue\n\n\nrC\nBoolean\nSelect the nucleic residue rC\nTrue\n\n\nrG\nBoolean\nSelect the nucleic residue rG\nTrue\n\n\nrU\nBoolean\nSelect the nucleic residue rU\nTrue\n\n\n\n\n\nOutputs\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nSelection\nBoolean\nThe calculated selection\nFalse\n\n\nInverted\nBoolean\nThe inverse of the calculated selection\nFalse\n\n\n\n\n\n\nSelect Res Name Peptide\nSelect single or multiple protein residues by name. Includes the 20 naturally occurring amino acids.\nVideo\n\nInputs\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nALA\nBoolean\nSelect the AA residue ALA\nFalse\n\n\nARG\nBoolean\nSelect the AA residue ARG\nFalse\n\n\nASN\nBoolean\nSelect the AA residue ASN\nFalse\n\n\nASP\nBoolean\nSelect the AA residue ASP\nFalse\n\n\nCYS\nBoolean\nSelect the AA residue CYS\nFalse\n\n\nGLU\nBoolean\nSelect the AA residue GLU\nFalse\n\n\nGLN\nBoolean\nSelect the AA residue GLN\nFalse\n\n\nGLY\nBoolean\nSelect the AA residue GLY\nFalse\n\n\nHIS\nBoolean\nSelect the AA residue HIS\nFalse\n\n\nILE\nBoolean\nSelect the AA residue ILE\nFalse\n\n\nLEU\nBoolean\nSelect the AA residue LEU\nFalse\n\n\nLYS\nBoolean\nSelect the AA residue LYS\nFalse\n\n\nMET\nBoolean\nSelect the AA residue MET\nFalse\n\n\nPHE\nBoolean\nSelect the AA residue PHE\nFalse\n\n\nPRO\nBoolean\nSelect the AA residue PRO\nFalse\n\n\nSER\nBoolean\nSelect the AA residue SER\nFalse\n\n\nTHR\nBoolean\nSelect the AA residue THR\nFalse\n\n\nTRP\nBoolean\nSelect the AA residue TRP\nFalse\n\n\nTYR\nBoolean\nSelect the AA residue TYR\nFalse\n\n\nVAL\nBoolean\nSelect the AA residue VAL\nFalse\n\n\n\n\n\nOutputs\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nSelection\nBoolean\nThe calculated selection\nFalse\n\n\nInverted\nBoolean\nThe inverse of the calculated selection\nFalse\n\n\n\n\n\n\nSelect Res Whole\nExpand the given selection to include a whole residue, if a single atom in that residue is selected. Useful for when a distance or proximity selection includes some of the residue and you wish to include all of the residue.\nVideo\n\nInputs\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nSelection\nBoolean\nExpands given selection to include the entire residue.\nFalse\n\n\n\n\n\nOutputs\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nSelection\nBoolean\nThe calculated selection\nFalse\n\n\n\n\n\n\nSelect Sec Struct\nSelect based on the assigned secondary structure information. Only returns a selection if the sec_struct attribute exists on the atoms. Will be imported from files where it is present, or can be calculated using the `MN_utils_dssp’ node.\nVideo\n\nOutputs\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nis_alpha_helix\nBoolean\n\nFalse\n\n\nis_beta_sheet\nBoolean\n\nFalse\n\n\nis_not_loop\nBoolean\n\nFalse\n\n\nis_loop\nBoolean\n\nFalse\n\n\n\n\n\n\nSelect Separate Atoms\nSelect only the desired input atoms. The output is bits of geometry, which include the selection and include the inverse of the selected atoms. You can expand the selection to include an entire residue if a single atom in that residue is selected, by setting Whole Residue to True.\nVideo\n\nInputs\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nAtoms\nGeometry\nAtomic geometry that contains vertices and edges.\nrequired\n\n\nSelection\nBoolean\nThe selection to separate the atoms.\nTrue\n\n\nWhole Residue\nBoolean\nExpands given selection to include the entire residue.\nFalse\n\n\n\n\n\nOutputs\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nAtoms\nGeometry\nThe selected atoms.\nrequired\n\n\nInverted\nGeometry\nThe inverse of the calculated selection\nrequired\n\n\nIndex\nInteger\nIndex of the Atoms before selection.\n0\n\n\n\n\n\n\nSelect Separate Polymers\nSeparate the input atomic geometry into it’s different polymers or Protein, Nucleic Acid and other.\nVideo\n\nInputs\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nAtoms\nGeometry\nAtomic geometry that contains vertices and edges.\nrequired\n\n\n\n\n\nOutputs\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nProtein\nGeometry\n\nrequired\n\n\nNucleic Acid\nGeometry\n\nrequired\n\n\nOther\nGeometry\n\nrequired\n\n\n\n\n\n\nSelect Sphere\nCreate a selection that is within a spherical radius of an object, based on that object’s scale. By default an empty object called Empty_Sphere is created. You can use other objects or create a new empty to use. The origin point for the object will be used, which should be taken in to account when using molecules. Use MN_select_proximity for selections which are within a certain distance of a selection of atoms instead of a single origin point.\nVideo\n\nInputs\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nObject\nObject\n\nrequired\n\n\nFrom Min (A)\nFloat\n\n0.0\n\n\nFrom Max (A)\nFloat\n\n10.0\n\n\n\n\n\nOutputs\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nSelection\nBoolean\nThe calculated selection\nFalse\n\n\nInverted\nBoolean\nThe inverse of the calculated selection\nFalse\n\n\n0..1\nFloat\n\n0.0"
  },
  {
    "objectID": "nodes.html#style",
    "href": "nodes.html#style",
    "title": "Nodes",
    "section": "Style",
    "text": "Style\n\nStyle Atoms\nStyle to apply the traditional space-filling atomic representation of atoms. Spheres are scaled based on the vdw_radii attribute. By default the Point Cloud rendering system is used, which is only visible inside of Cycles.\nVideo\n\nInputs\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nAtoms\nGeometry\nAtomic geometry that contains vertices and edges.\nrequired\n\n\nSelection\nBoolean\nSelection for applying the style. Unselected is discarded.\nTrue\n\n\n[ ] Cycles / [x] Eevee\nBoolean\nUse Eevee or Cycles compatible atoms.\nFalse\n\n\nScale Radii\nFloat\nScale the vdw_radii of the atoms.\n0.8\n\n\nEevee: Subdivisions\nInteger\nSubdivisions for Eevee compatible atoms.\n2\n\n\nEevee: Shade Smooth\nBoolean\nShade Eevee compatible atoms smooth.\nTrue\n\n\nMaterial\nMaterial\nMaterial to apply to resulting style.\nMN_atomic_style\n\n\n\n\n\nOutputs\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nGeometry\nGeometry\n\nrequired\n\n\n\n\n\n\nStyle Ball And Stick\nStyle that creates cylinders for bonds and spheres for atoms. The atoms can be either Eevee or Cycles compatible, with customisation to resolution and radius possible.\nVideo\n\nInputs\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nAtoms\nGeometry\nAtomic geometry that contains vertices and edges.\nrequired\n\n\nSelection\nBoolean\n\nTrue\n\n\nAtom: Eevee / Cycles\nBoolean\n\nTrue\n\n\nAtom: Scale Radii\nFloat\n\n0.3\n\n\nAtom: Subdivisions\nInteger\n\n2\n\n\nBond: Radius\nFloat\n\n0.3\n\n\nBond: Resolution\nInteger\n\n6\n\n\nShade Smooth\nBoolean\n\nTrue\n\n\nMaterial\nMaterial\n\nMN_atomic_style\n\n\n\n\n\nOutputs\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nGeometry\nGeometry\n\nrequired\n\n\n\n\n\n\nStyle Cartoon\nStyle to apply the traditional cartoon representation of protein structures. This style highlights alpha-helices and beta-sheets with arrows and cylinders.\nVideo\n\nInputs\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nAtoms\nGeometry\nAtomic geometry that contains vertices and edges.\nrequired\n\n\nSelection\nBoolean\nSelection for applying the style. Unselected is discarded.\nTrue\n\n\nQuality\nInteger\nNumber of subdivisions, ‘quality’ of the cartoon.\n2\n\n\nSmooth / Sharp\nBoolean\nCreate smooth or sharp style cartoon geometry.\nFalse\n\n\nArrows\nBoolean\nCreate arrows for beta-sheet cartoons.\nTrue\n\n\nCylinders\nBoolean\nCreate cylinders for alpha-helix geometry.\nFalse\n\n\nThickness\nFloat\nThickness of the secondary structure geometry.\n0.4\n\n\nWidth\nFloat\nWidth of the secondary structure geometry.\n1.8\n\n\nLoop Radius\nFloat\nRadius of the loop geometry.\n0.18\n\n\nBS Smooth\nFloat (Factor)\nFactor 0 -&gt; 1, amount to flatten the beta-sheets.\n1.0\n\n\nShade Smooth\nBoolean\nShade the resulting geometry smooth.\nTrue\n\n\nMaterial\nMaterial\nMaterial to apply to resulting style.\nMN_atomic_style\n\n\n\n\n\nOutputs\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nCartooon Mesh\nGeometry\n\nrequired\n\n\n\n\n\n\nStyle Ribbon Nucleic\nStyle that creates a continuous ribbon through the backbone of nucleic acids, and s simplified cylinder for the bases.\nVideo\n\nInputs\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nAtoms\nGeometry\nAtomic geometry that contains vertices and edges.\nrequired\n\n\nSelection\nBoolean\n\nTrue\n\n\nBackbone\nInteger\n\n3\n\n\nResolution\nInteger\n\n8\n\n\nRibbon Radius\nFloat (Distance)\n\n2.0\n\n\nBase Radius\nFloat (Distance)\n\n0.2\n\n\nBase Resolution\nInteger\n\n6\n\n\nA\nColor\n\nrgb(69, 139, 204)◉\n\n\nC\nColor\n\nrgb(75, 204, 47)◉\n\n\nG\nColor\n\nrgb(204, 60, 42)◉\n\n\nT/U\nColor\n\nrgb(204, 68, 134)◉\n\n\nShade Backbone Smooth\nBoolean\n\nTrue\n\n\nMaterial\nMaterial\n\nMN_atomic_style\n\n\n\n\n\nOutputs\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nRibbon + Bases\nGeometry\n\nrequired\n\n\nBase Instances\nGeometry\n\nrequired\n\n\nRibbon Mesh\nGeometry\n\nrequired\n\n\nRibbon Curve\nGeometry\n\nrequired\n\n\n\n\n\n\nStyle Ribbon Protein\nStyle that creates a continuous solid ribbon or ‘licorice’ tube through the alpha-carbons of the structure.\nVideo\n\nInputs\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nAtoms\nGeometry\nAtomic geometry that contains vertices and edges.\nrequired\n\n\nSelection\nBoolean\n\nTrue\n\n\nQuality\nInteger\n\n3\n\n\nRadius\nFloat\n\n2.0\n\n\nBS Smoothing\nFloat (Factor)\n\n1.0\n\n\nShade Smooth\nBoolean\n\nTrue\n\n\nMaterial\nMaterial\n\nMN_atomic_style\n\n\n\n\n\nOutputs\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nRibbon Mesh\nGeometry\n\nrequired\n\n\nRibbon Curve\nGeometry\n\nrequired\n\n\nUVs\nVector\n\n[0.0, 0.0, 0.0]\n\n\n\n\n\n\nStyle Sticks\nStyle that creates a cylinder for each bond. Cylindrical caps to the cylinders are currently not supported. Best to use MN_style_ball_and_stick.\nVideo\n\nInputs\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nAtoms\nGeometry\nAtomic geometry that contains vertices and edges.\nrequired\n\n\nRadius\nFloat\n\n0.3\n\n\nResolution\nInteger\n\n6\n\n\nFill Caps\nBoolean\n\nFalse\n\n\nInterpolate Color\nBoolean\n\nFalse\n\n\nShade Smooth\nBoolean\n\nTrue\n\n\nMaterial\nMaterial\n\nMN_atomic_style\n\n\n\n\n\nOutputs\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nSticks\nGeometry\n\nrequired\n\n\n\n\n\n\nStyle Surface\nStyle that creates a surface representation based on the proximity of atoms to a probe that is moved through the entire structure.\nVideo\n\nInputs\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nAtoms\nGeometry\nAtomic geometry that contains vertices and edges.\nrequired\n\n\nSelection\nBoolean\n\nTrue\n\n\nQuality\nInteger\n\n12\n\n\nScale Radii\nFloat\n\n1.0\n\n\nProbe Size\nFloat\n\n0.6\n\n\nSurface Smoothing\nInteger\n\n2\n\n\nColor by CA\nBoolean\n\nTrue\n\n\nInterpolate Color\nInteger\n\n1\n\n\nShade Smooth\nBoolean\n\nTrue\n\n\nMaterial\nMaterial\n\nMN_atomic_style\n\n\n\n\n\nOutputs\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nSurface Geometry\nGeometry\n\nrequired\n\n\nVolume\nGeometry\n\nrequired"
  },
  {
    "objectID": "nodes.html#utils",
    "href": "nodes.html#utils",
    "title": "Nodes",
    "section": "Utils",
    "text": "Utils\n\nUtils Curve Resample\nStyle that creates a surface representation based on the proximity of atoms to a probe that is moved through the entire structure.\nVideo\n\nInputs\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nGeometry\nGeometry\n\nrequired\n\n\nOffset\nFloat\n\n2.3\n\n\nLength\nFloat (Distance)\n\n0.36\n\n\nField Float\nFloat\n\n0.0\n\n\nField Int\nInteger\n\n0\n\n\nField Vec\nVector\n\n[0.0, 0.0, 0.0]\n\n\n\n\n\nOutputs\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nGeometry\nGeometry\n\nrequired\n\n\nPosition\nVector\n\n[0.0, 0.0, 0.0]\n\n\nTangent\nVector\n\n[0.0, 0.0, 0.0]\n\n\nNormal\nVector\n\n[0.0, 0.0, 0.0]\n\n\nField Float\nFloat\n\n0.0\n\n\nField Int\nInteger\n\n0\n\n\nField Vec\nVector\n\n[0.0, 0.0, 0.0]\n\n\n\n\n\n\nUtils Dssp\nA rudimentary secondary structure detection algorithm.\nVideo\n\nInputs\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nInput\nGeometry\n\nrequired\n\n\nH-bond Cutoff\nFloat\n\n2.5\n\n\n\n\n\nOutputs\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nAtoms\nGeometry\n\nrequired\n\n\n\n\n\n\nUtils Extend Curve\nA rudimentary secondary structure detection algorithm.\nVideo\n\nInputs\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nGeometry\nGeometry\n\nrequired\n\n\nSmoothing Iterations\nInteger\n\n4\n\n\nSmoothing Distance\nFloat (Distance)\n\n1.0\n\n\nExtend Distance\nFloat\n\n6.58\n\n\n\n\n\nOutputs\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nDNA Curve\nGeometry\n\nrequired\n\n\n\n\n\n\nUtils Helix\nA rudimentary secondary structure detection algorithm.\nVideo\n\nInputs\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nGeometry\nGeometry\n\nrequired\n\n\nValue\nFloat\n\n0.57\n\n\nScale\nFloat\n\n0.1\n\n\nRotation\nFloat\n\n0.5\n\n\nAngle\nFloat (Angle)\n\n-0.8\n\n\nUnwind\nFloat\n\n1.0\n\n\nOffset\nFloat\n\n0.01\n\n\nLength\nFloat (Distance)\n\n0.04\n\n\nOffset\nInteger\n\n2\n\n\n\n\n\nOutputs\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nCurve\nGeometry\n\nrequired\n\n\npos_old - pos_new\nVector\n\n[0.0, 0.0, 0.0]\n\n\n\n\n\n\nUtils Nuc Atom Pos\nA rudimentary secondary structure detection algorithm.\nVideo\n\nInputs\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\natom_name\nInteger\n\n5\n\n\n\n\n\nOutputs\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nPosition\nVector\n\n[0.0, 0.0, 0.0]\n\n\nGroup Index\nInteger\n\n0\n\n\nb_factor\nFloat\n\n0.0\n\n\nInteger\nInteger\n\n0\n\n\nhas_base\nBoolean\n\nFalse\n\n\n\n\n\n\nUtils Primitive Atom\nA rudimentary secondary structure detection algorithm.\nVideo\n\nInputs\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nPosition\nVector\n\n[0.0, 0.0, 0.0]\n\n\nvdw_radii\nFloat (Distance)\n\n0.1\n\n\nb_factor\nFloat\n\n0.0\n\n\natomic_number\nInteger\n\n0\n\n\nres_name\nInteger\n\n0\n\n\nres_id\nInteger\n\n0\n\n\nis_backbone\nBoolean\n\nFalse\n\n\nis_peptide\nBoolean\n\nFalse\n\n\nis_alpha_carbon\nBoolean\n\nFalse\n\n\nis_nucleic\nBoolean\n\nFalse\n\n\n\n\n\nOutputs\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nGeometry\nGeometry\n\nrequired\n\n\n\n\n\n\nUtils Style Atoms Cycles\nA rudimentary secondary structure detection algorithm.\nVideo\n\nInputs\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nAtoms\nGeometry\nAtomic geometry that contains vertices and edges.\nrequired\n\n\nSelection\nBoolean\n\nTrue\n\n\nScale Radii\nFloat\n\n0.8\n\n\nMaterial\nMaterial\n\nMN_atomic_style\n\n\n\n\n\nOutputs\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nAtom Point Cloud\nGeometry\n\nrequired\n\n\n\n\n\n\nUtils Style Atoms Eevee\nA rudimentary secondary structure detection algorithm.\nVideo\n\nInputs\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nAtoms\nGeometry\nAtomic geometry that contains vertices and edges.\nrequired\n\n\nSelection\nBoolean\n\nTrue\n\n\nScale Radii\nFloat\n\n0.8\n\n\nSubdivisions\nInteger\n\n2\n\n\nShade Smooth\nBoolean\n\nTrue\n\n\nMaterial\nMaterial\n\nMN_atomic_style\n\n\n\n\n\nOutputs\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nAtom Instances\nGeometry\n\nrequired\n\n\n\n\n\n\nUtils Style Cartoon\nA rudimentary secondary structure detection algorithm.\nVideo\n\nInputs\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nAtoms\nGeometry\nAtomic geometry that contains vertices and edges.\nrequired\n\n\nSelection\nBoolean\n\nTrue\n\n\nProfile Resolution\nInteger\n\n4\n\n\nProfile Curve\nGeometry\nA custom curve-cirlce making SS ribbons.\nrequired\n\n\nAH Ribbon Rotate\nFloat\n\n0.0\n\n\nAH Ribbon Thickness\nFloat\n\n0.5\n\n\nAH Ribbon Width\nFloat\n\n2.0\n\n\nAH Subdiv\nInteger\n\n5\n\n\nAH Curve Smooth\nBoolean\nSmoothen out AH to be more cylindrical.\nTrue\n\n\nCylinder Radius\nFloat\n\n2.0\n\n\nCylinder Resolution\nInteger\n\n12\n\n\nCylinder Subdivisions\nInteger\n\n5\n\n\nCylinders\nBoolean\n\nFalse\n\n\nCylinders Curved\nBoolean\n\nTrue\n\n\nBS Ribbon Rotate\nFloat\n\n0.0\n\n\nBS Ribbon Thickness\nFloat\n\n0.5\n\n\nBS Ribbon Width\nFloat\n\n2.0\n\n\nBS Smooth\nFloat\n\n1.0\n\n\nBS Subdivision\nInteger\n\n3\n\n\nArrows\nBoolean\nRender beta-strands with directional arrows.\nFalse\n\n\nArrows Sharp\nBoolean\n\nFalse\n\n\nArrows Point\nBoolean\n\nFalse\n\n\nArrow Thickness Scale\nFloat\n\n1.0\n\n\nArrow Width Scale\nFloat\n\n1.0\n\n\nLoop Subdivisions\nInteger\n\n6\n\n\nLoop Radius\nFloat\n\n0.3\n\n\nLoop Resolution\nInteger\n\n8\n\n\nShade Smooth\nBoolean\n\nTrue\n\n\nMaterial\nMaterial\n\nMN_atomic_style\n\n\n\n\n\nOutputs\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nCartoon Mesh\nGeometry\n\nrequired\n\n\n\n\n\n\nUtils Style Old Ball And Stick\nA rudimentary secondary structure detection algorithm.\nVideo\n\nInputs\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nAtoms\nGeometry\nAtomic geometry that contains vertices and edges.\nrequired\n\n\nSelection\nBoolean\n\nTrue\n\n\nShade Smooth\nBoolean\n\nTrue\n\n\nBall Resolution\nInteger\n\n2\n\n\nBall Radius\nFloat (Distance)\n\n0.3\n\n\nFind Bonds\nBoolean\n\nFalse\n\n\nBond Resolution\nInteger\n\n8\n\n\nBond Radius\nFloat\n\n0.2\n\n\nSplit Double Bonds\nBoolean\n\nFalse\n\n\nDouble Bond Curve\nFloat\n\n1.0\n\n\nDouble Bond Width\nFloat\n\n1.0\n\n\nDouble Bond Resolution\nInteger\n\n3\n\n\nDouble Bond Radius\nFloat\n\n0.2\n\n\nDouble Bond Rotate\nFloat\n\n0.0\n\n\nMaterial\nMaterial\n\nMN_atomic_style\n\n\n\n\n\nOutputs\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nBall and Stick Mesh\nGeometry\n\nrequired\n\n\nSticks Mesh\nGeometry\n\nrequired\n\n\nBall Instances\nGeometry\n\nrequired"
  },
  {
    "objectID": "tutorials/02_selections.html",
    "href": "tutorials/02_selections.html",
    "title": "Selections",
    "section": "",
    "text": "Selections power every part of Molecular Visualisation. You are probably used to using selections via manually pointing and clicking with your mouse, or typing long strings of complex selection algebra."
  },
  {
    "objectID": "tutorials/02_selections.html#a-simple-example",
    "href": "tutorials/02_selections.html#a-simple-example",
    "title": "Selections",
    "section": "A Simple Example",
    "text": "A Simple Example\nTo create a selection of residues ALA, CYS and TRP, only inside of chain A, you would use the following code inside of PyMol:\nselect my_selection, chain A and (resn ALA+CYS+TRP)\nInside of Molecular Nodes, you combine different selection nodes using Boolean Math nodes to create increasingly complex selections.\n\n\n\nReplicating the same selection in Molecular Nodes\n\n\nThis might initially seem quite verbose. The good thing however is that these selections can always be updated and tweaked. They can even be created procedurally based on the values of other selections or animations.\nIn the example video below we are using the selection to apply the Atoms style. We can change the residues and chains that are selected by ticking and unticking the boxes. Each of these selections also take a field input, so they can use the output of other selection nodes. The selections from the two nodes are being combined with the Boolean Math node set to And. Other boolean math operations are also available.\nVideo"
  },
  {
    "objectID": "tutorials/02_selections.html#different-styles-combined",
    "href": "tutorials/02_selections.html#different-styles-combined",
    "title": "Selections",
    "section": "Different Styles Combined",
    "text": "Different Styles Combined\nIn this example, we apply the Surface style to one chain, and the Atoms style to another chain. We can join the two styles together with the Join Geometry node.\nVideo"
  },
  {
    "objectID": "tutorials/02_selections.html#combining-selections",
    "href": "tutorials/02_selections.html#combining-selections",
    "title": "Selections",
    "section": "Combining Selections",
    "text": "Combining Selections\nSelections can be combined not just through Boolean Math nodes, but also by connecting the output from one node to the input of another selection. In this example we are selecting two chains for applying the Atoms style to.\nThe selection of Chain A we then control though the Cube selection node. The addition of this node creates a new object called Empty_Cube which we can transform by Grabbing, Rotating and Scaling to change what is inside of the cube. The style is then applied to the updated selection, which varies for Cahin A but not for Chain F.\nVideo"
  },
  {
    "objectID": "tutorials/02_selections.html#more-examples",
    "href": "tutorials/02_selections.html#more-examples",
    "title": "Selections",
    "section": "More Examples",
    "text": "More Examples\nYou can use these dynamic selections for any kind of boolean input. It can be used to select the atoms to apply a style to or even to change different aspects of that style itself. In this example, we first choose the atoms to apply the style to; then instead, we change whether or not we use cylinders for the cartoon style.\nVideo\nSelecting based on the entity_id, to reveal the rotary axel of the protein complex underneath.\nVideo"
  },
  {
    "objectID": "tutorials/02_selections.html#open-a-local-file",
    "href": "tutorials/02_selections.html#open-a-local-file",
    "title": "Selections",
    "section": "Open a Local File",
    "text": "Open a Local File\nTo open a .pdb, .mmCIF, .pdbx or other similar files, use the Local File tab.\nYou can set the name for the molecule, which will become the object’s name once imported. Use the folder icon to select the file you would like to import.\n\n\n\nThe ‘Local File’ tab.\n\n\nThe ‘Default Style’ was changed to ‘Cartoon’, but no other default import options were changed. The Default Cube was deleted with X as the protein was imported inside of the cube."
  },
  {
    "objectID": "installation.html",
    "href": "installation.html",
    "title": "Installation",
    "section": "",
    "text": "Molecular Nodes is an add-on for the 3D animation program Blender. It runs inside of Blender, so the first step for installation is to download and install the latest version of blender.\n\n\n\nThe download page of Blender."
  },
  {
    "objectID": "installation.html#downloading-blender",
    "href": "installation.html#downloading-blender",
    "title": "Installation",
    "section": "",
    "text": "Molecular Nodes is an add-on for the 3D animation program Blender. It runs inside of Blender, so the first step for installation is to download and install the latest version of blender.\n\n\n\nThe download page of Blender."
  },
  {
    "objectID": "installation.html#downloading-molecular-nodes",
    "href": "installation.html#downloading-molecular-nodes",
    "title": "Installation",
    "section": "Downloading Molecular Nodes",
    "text": "Downloading Molecular Nodes\nDownload the latest bundled release from the releases page. Don’t download the GitHub repo itself, as this won’t install inside of Blender.\n\n\n\n\n\n\nSafari\n\n\n\nWhen downloading on MacOS with Safari, it automatically unzips the file into a MolecularNodes folder. This is extremely unhelpful as Blender requires the .zip file to install the addon. Either download with a different browser, or compress the folder again to MolecularNodes.zip."
  },
  {
    "objectID": "installation.html#installing-the-addon",
    "href": "installation.html#installing-the-addon",
    "title": "Installation",
    "section": "Installing the Addon",
    "text": "Installing the Addon\n\n\n\n\n\n\nWindows Administrator\n\n\n\nIf you are on Windows, you may need to run Blender as Administrator to successfully complete the following installation.\n\n\n\nOpen Preferences Panel\n\nClick `Edit’ -&gt; ‘Preferences’ or press Cmd +  , on Mac.\n\n\n\n\nClick ‘Install’ while in ‘Add-ons’\n\n\n\nSelect MolecularNodes_X.zip\n\nThe X’s will be the current version number of the add-on."
  },
  {
    "objectID": "installation.html#installing-biotite-mdanalysis",
    "href": "installation.html#installing-biotite-mdanalysis",
    "title": "Installation",
    "section": "Installing Biotite & MDAnalysis",
    "text": "Installing Biotite & MDAnalysis\nTo import different data formats, different python packages are required to be installed. Each python package is responsible for importing a different data format.\n\nBiotite: handles the majority of .pdb / .cif file parsing and downloading from the wwPDB.\nMDAnalysis: enables import of molecular dynamics trajectories from programs such as GROMACS / LAMMPS.\nmrcfile: enables import of electron microscopy densities and EM tomography .map files.\n\nEach of these packages should be fine to be installed by a single click. Blender will freeze for potentially a minute or so during installation. Currently M1 / M2 macs require more complex installation to install MDAnalysis, please see the instructions below. Downloading from the wwPDB and opening local .pdb files with Biotite should work fine without MDAnalysis installed.\n\n\n\n\n\n\nMacOS M1 & M2\n\n\n\n\n\nBlender’s bundled python is unable to install python packages that require compilation on the user’s machine. Currently, MDAnalysis is missing a pre-compiled .whl to install, and thus installation will fail on M1 & M2 machines. You can download and pre-compile these packages on your machine yourself, following the below instructions.\nThis is the current fix for M1 / M2 machines, but will be fixed in future releases.\nIn short:\n\nInstall miniconda\nDownload and build the required packages for your system\n\nmkdir ~/MDAnalysis-wheel\ncd MDAnalysis-wheel\nconda create -n wheel-builder python=3.10 cython\nconda activate wheel-builder\npython -m pip wheel MDAnalysis==2.5.0 --cache-dir .\nconda deactivate\n\nInstall the built .whl packages, into Blender’s bundled python. The path to your\n\nNavigate to your Blender’s python folder (this is the default path for Blender 3.5)\ncd /Applications/Blender.app/Contents/Resources/3.5/python/bin/\nInstall the cached .whl into the bundled python that came with Blender.\n./python3.10 -m pip install MDAnalysis --cache-dir ~/MDAnalysis-wheel\nThe Install MDAnalysis button should have updated to detect the MDAnalysis installation.\n\n\n\n\nA message should report the successful installation of each package, with the button changing to Reinstall biotite once Molecular Nodes detects the successful installation of the package.\nYou may need to restart Blender after package installation for them to work properly.\nIf you have troubled with installation, search through the issues page for a potential solution. If you can’t find the solution there, please open a new issue on the GitHub page. Please don’t just DM or email me directly. It’s better to do problem solving out in the open, as others might have the same issue or someone other than me may already have a solution!"
  },
  {
    "objectID": "reference/coll.html",
    "href": "reference/coll.html",
    "title": "coll",
    "section": "",
    "text": "``\n\n\n\n\n\nName\nDescription\n\n\n\n\ndata\nA collection for storing MN related data objects.\n\n\nframes\nCreate a Collection for Frames of a Trajectory\n\n\nmn\nReturn the MolecularNodes Collection\n\n\n\n\n\n\ndata(name='data')\nA collection for storing MN related data objects.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nname\nstr, optional\nName of the data collection. Default is “data”.\n'data'\n\n\n\n\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nbpy.types.Collection\nThe collection for storing MN related data objects.\n\n\n\n\n\n\n\nframes(name='', parent=None, prefix='frames')\nCreate a Collection for Frames of a Trajectory\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nname\nstr, optional\nName of the collection for the frames. Default is ““.\n''\n\n\nparent\nbpy.types.Collection, optional\nA blender collection which will become the parent collection. Default is the MolecularNodes collection if None.\nNone\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nbpy.types.Collection\nThe newly created collection for frames.\n\n\n\n\n\n\n\nmn()\nReturn the MolecularNodes Collection\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nbpy.types.Collection\nThe ‘MolecularNodes’ collection inside the Blender scene. If it doesn’t exist, it will be created."
  },
  {
    "objectID": "reference/coll.html#functions",
    "href": "reference/coll.html#functions",
    "title": "coll",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\ndata\nA collection for storing MN related data objects.\n\n\nframes\nCreate a Collection for Frames of a Trajectory\n\n\nmn\nReturn the MolecularNodes Collection"
  },
  {
    "objectID": "reference/coll.html#coll.data",
    "href": "reference/coll.html#coll.data",
    "title": "coll",
    "section": "",
    "text": "data(name='data')\nA collection for storing MN related data objects.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nname\nstr, optional\nName of the data collection. Default is “data”.\n'data'\n\n\n\n\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nbpy.types.Collection\nThe collection for storing MN related data objects."
  },
  {
    "objectID": "reference/coll.html#coll.frames",
    "href": "reference/coll.html#coll.frames",
    "title": "coll",
    "section": "",
    "text": "frames(name='', parent=None, prefix='frames')\nCreate a Collection for Frames of a Trajectory\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nname\nstr, optional\nName of the collection for the frames. Default is ““.\n''\n\n\nparent\nbpy.types.Collection, optional\nA blender collection which will become the parent collection. Default is the MolecularNodes collection if None.\nNone\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nbpy.types.Collection\nThe newly created collection for frames."
  },
  {
    "objectID": "reference/coll.html#coll.mn",
    "href": "reference/coll.html#coll.mn",
    "title": "coll",
    "section": "",
    "text": "mn()\nReturn the MolecularNodes Collection\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nbpy.types.Collection\nThe ‘MolecularNodes’ collection inside the Blender scene. If it doesn’t exist, it will be created."
  },
  {
    "objectID": "reference/md.html",
    "href": "reference/md.html",
    "title": "md",
    "section": "",
    "text": "``\nImporting molecular dynamics trajectories and associated files.\n\n\n\n\n\nName\nDescription\n\n\n\n\nload_trajectory\nLoads a molecular dynamics trajectory from the specified files.\n\n\npanel\n\n\n\n\n\n\n\nload_trajectory(file_top, file_traj, name='NewTrajectory', md_start=0, md_end=49, md_step=1, world_scale=0.01, include_bonds=True, selection='not (name H* or name OW)', custom_selections=None)\n\n\nfile_top : str The path to the topology file. file_traj : str The path to the trajectory file. name : str, optional The name of the trajectory (default: “default”). md_start : int, optional The starting frame of the trajectory to load (default: 0). md_end : int, optional The ending frame of the trajectory to load (default: 49). md_step : int, optional The step size between frames to load (default: 1). world_scale : float, optional The scaling factor for the world coordinates (default: 0.01). include_bonds : bool, optional Whether to include bond information if available (default: True). selection : str, optional The selection string for atom filtering (default: “not (name H* or name OW)”). Uses MDAnalysis selection syntax. custom_selections : dict or None, optional A dictionary of custom selections for atom filtering with {‘name’ : ‘selection string’} (default: None).\n\n\n\nMN_object : bpy.types.Object The loaded topology file as a blender object. coll_frames : bpy.types.Collection The loaded trajectory as a blender collection.\n\n\n\nFileNotFoundError If the topology or trajectory file is not found. IOError If there is an error reading the files.\n\n\n\n\npanel(layout_function, scene)"
  },
  {
    "objectID": "reference/md.html#functions",
    "href": "reference/md.html#functions",
    "title": "md",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nload_trajectory\nLoads a molecular dynamics trajectory from the specified files.\n\n\npanel"
  },
  {
    "objectID": "reference/md.html#md.load_trajectory",
    "href": "reference/md.html#md.load_trajectory",
    "title": "md",
    "section": "",
    "text": "load_trajectory(file_top, file_traj, name='NewTrajectory', md_start=0, md_end=49, md_step=1, world_scale=0.01, include_bonds=True, selection='not (name H* or name OW)', custom_selections=None)\n\n\nfile_top : str The path to the topology file. file_traj : str The path to the trajectory file. name : str, optional The name of the trajectory (default: “default”). md_start : int, optional The starting frame of the trajectory to load (default: 0). md_end : int, optional The ending frame of the trajectory to load (default: 49). md_step : int, optional The step size between frames to load (default: 1). world_scale : float, optional The scaling factor for the world coordinates (default: 0.01). include_bonds : bool, optional Whether to include bond information if available (default: True). selection : str, optional The selection string for atom filtering (default: “not (name H* or name OW)”). Uses MDAnalysis selection syntax. custom_selections : dict or None, optional A dictionary of custom selections for atom filtering with {‘name’ : ‘selection string’} (default: None).\n\n\n\nMN_object : bpy.types.Object The loaded topology file as a blender object. coll_frames : bpy.types.Collection The loaded trajectory as a blender collection.\n\n\n\nFileNotFoundError If the topology or trajectory file is not found. IOError If there is an error reading the files."
  },
  {
    "objectID": "reference/md.html#md.panel",
    "href": "reference/md.html#md.panel",
    "title": "md",
    "section": "",
    "text": "panel(layout_function, scene)"
  },
  {
    "objectID": "reference/pkg.html",
    "href": "reference/pkg.html",
    "title": "pkg",
    "section": "",
    "text": "``\nHandling installation of external python packages inside of Blender’s bundled python.\n\n\n\n\n\nName\nDescription\n\n\n\n\nADDON_DIR\nFolder for the addon on the local machine.\n\n\nPYPI_MIRROR\nPossible PyPi mirrors to install from.\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nget_pkgs\nRead a requirements file and extract package information into a dictionary.\n\n\nget_pypi_mirror_alias\nGet the available PyPI mirror aliases.\n\n\ninstall_all_packages\nInstall all packages listed in the ‘requirements.txt’ file.\n\n\ninstall_package\nInstall a Python package and its dependencies using pip.\n\n\nis_available\nCheck if a given package is available with the specified version.\n\n\nis_current\nCheck if the specified package is the current version.\n\n\nprocess_pypi_mirror_to_url\nProcess a PyPI mirror provider and return the corresponding URL.\n\n\nrun_python\nRuns pip command using the specified command list and returns the command output.\n\n\nstart_logging\nConfigure and start logging to a file.\n\n\n\n\n\n\nget_pkgs(requirements=None)\nRead a requirements file and extract package information into a dictionary.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nrequirements\nstr, optional\nThe path to the requirements file. If not provided, the function looks for a requirements.txt file in the same directory as the script.\nNone\n\n\n\n\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\ndict\nA dictionary containing package information. Each element of the dictionary is a dictionary containing the package name, version, and description.\n\n\n\n\n\n\nGiven the following requirements file:\nFlask==1.1.2 # A micro web framework for Python\npandas==1.2.3 # A fast, powerful, flexible, and easy-to-use data analysis and manipulation tool\nnumpy==1.20.1 # Fundamental package for scientific computing\nThe function would return the following dictionary:\n[\n    {\n        \"package\": \"Flask\",\n        \"version\": \"1.1.2\",\n        \"desc\": \"A micro web framework for Python\"\n    },\n    {\n        \"package\": \"pandas\",\n        \"version\": \"1.2.3\",\n        \"desc\": \"A fast, powerful, flexible, and easy-to-use data analysis and manipulation tool\"\n    },\n    {\n        \"package\": \"numpy\",\n        \"version\": \"1.20.1\",\n        \"desc\": \"Fundamental package for scientific computing\"\n    }\n]\n\n\n\n\nget_pypi_mirror_alias(self, context, edit_text)\nGet the available PyPI mirror aliases.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nself\nobject\nThe object instance.\nrequired\n\n\ncontext\n…\nThe context parameter (description missing).\nrequired\n\n\nedit_text\n…\nThe edit_text parameter (description missing).\nrequired\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nkeys_view\nA view object of the available PyPI mirror aliases.\n\n\n\n\n\n\n\ninstall_all_packages(pypi_mirror_provider='Default')\nInstall all packages listed in the ‘requirements.txt’ file.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npypi_mirror_provider\nstr, optional\nThe PyPI mirror to use for package installation. Defaults to ‘Default’, which uses the official PyPI repository.\n'Default'\n\n\n\n\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nlist\nA list of tuples containing the installation results for each package.\n\n\n\n\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nInstallationError\nIf there is an error during package installation.\n\n\n\n\n\n\nTo install all packages listed in the ‘requirements.txt’ file, run the following command:\ninstall_all_packages(pypi_mirror_provider='https://pypi.org/simple/')\n\n\n\n\ninstall_package(package, pypi_mirror_provider='Default')\nInstall a Python package and its dependencies using pip.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npackage\nstr\nThe name of the package to install.\nrequired\n\n\npypi_mirror_provider\nstr, optional\nThe name/url of the PyPI mirror provider to use. Default is ‘Default’.\n'Default'\n\n\n\n\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nlist\nA list of tuples containing the command list, return code, stdout, and stderr for each pip command run.\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nValueError\nIf the package name is not provided.\n\n\n\n\n\n\nTo install the package ‘requests’ from the PyPI mirror ‘MyMirror’, use:\ninstall_package('requests', 'MyMirror')\n\n\n\n\nis_available(package, version=None)\nCheck if a given package is available with the specified version.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npackage\nstr\nThe name of the package to check.\nrequired\n\n\nversion\nstr, optional\nThe version of the package to check.\nNone\n\n\n\n\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nbool\nTrue if the package with the specified version is available, False otherwise.\n\n\n\n\n\n\n&gt;&gt;&gt; is_available('numpy', '1.20.1')\nTrue\n\n\n\n\nis_current(package)\nCheck if the specified package is the current version.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npackage\nstr\nThe name of the package to check.\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nbool\nTrue if the package is the current version, False otherwise.\n\n\n\n\n\n\n\nprocess_pypi_mirror_to_url(pypi_mirror_provider)\nProcess a PyPI mirror provider and return the corresponding URL.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npypi_mirror_provider\nstr\nThe PyPI mirror provider to process.\nrequired\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nstr\nThe URL of the PyPI mirror.\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nValueError\nIf the provided PyPI mirror provider is invalid.\n\n\n\n\n\n\n\nrun_python(cmd_list=None, mirror_url='', timeout=600)\nRuns pip command using the specified command list and returns the command output.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncmd_list\nlist, optional\nList of pip commands to be executed. Defaults to None.\nNone\n\n\nmirror_url\nstr, optional\nURL of a package repository mirror to be used for the command. Defaults to ’’.\n''\n\n\ntimeout\nint, optional\nTime in seconds to wait for the command to complete. Defaults to 600.\n600\n\n\n\n\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\ntuple\nA tuple containing the command list, command return code, command standard output, and command standard error.\n\n\n\n\n\n\nInstall numpy using pip and print the command output\ncmd_list = [\"-m\", \"pip\", \"install\", \"numpy\"]\nmirror_url = 'https://pypi.org/simple/'\ncmd_output = run_python(cmd_list, mirror_url=mirror_url, timeout=300)\nprint(cmd_output)\n\n\n\n\nstart_logging(logfile_name='side-packages-install')\nConfigure and start logging to a file.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nlogfile_name\nstr, optional\nThe name of the log file. Defaults to ‘side-packages-install’.\n'side-packages-install'\n\n\n\n\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nlogging.Logger\nA Logger object that can be used to write log messages.\n\n\n\nThis function sets up a logging configuration with a specified log file name and logging level. The log file will be created in the ADDON_DIR/logs directory. If the directory does not exist, it will be created. The function returns a Logger object that can be used to write log messages."
  },
  {
    "objectID": "reference/pkg.html#attributes",
    "href": "reference/pkg.html#attributes",
    "title": "pkg",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nADDON_DIR\nFolder for the addon on the local machine.\n\n\nPYPI_MIRROR\nPossible PyPi mirrors to install from."
  },
  {
    "objectID": "reference/pkg.html#functions",
    "href": "reference/pkg.html#functions",
    "title": "pkg",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nget_pkgs\nRead a requirements file and extract package information into a dictionary.\n\n\nget_pypi_mirror_alias\nGet the available PyPI mirror aliases.\n\n\ninstall_all_packages\nInstall all packages listed in the ‘requirements.txt’ file.\n\n\ninstall_package\nInstall a Python package and its dependencies using pip.\n\n\nis_available\nCheck if a given package is available with the specified version.\n\n\nis_current\nCheck if the specified package is the current version.\n\n\nprocess_pypi_mirror_to_url\nProcess a PyPI mirror provider and return the corresponding URL.\n\n\nrun_python\nRuns pip command using the specified command list and returns the command output.\n\n\nstart_logging\nConfigure and start logging to a file."
  },
  {
    "objectID": "reference/pkg.html#pkg.get_pkgs",
    "href": "reference/pkg.html#pkg.get_pkgs",
    "title": "pkg",
    "section": "",
    "text": "get_pkgs(requirements=None)\nRead a requirements file and extract package information into a dictionary.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nrequirements\nstr, optional\nThe path to the requirements file. If not provided, the function looks for a requirements.txt file in the same directory as the script.\nNone\n\n\n\n\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\ndict\nA dictionary containing package information. Each element of the dictionary is a dictionary containing the package name, version, and description.\n\n\n\n\n\n\nGiven the following requirements file:\nFlask==1.1.2 # A micro web framework for Python\npandas==1.2.3 # A fast, powerful, flexible, and easy-to-use data analysis and manipulation tool\nnumpy==1.20.1 # Fundamental package for scientific computing\nThe function would return the following dictionary:\n[\n    {\n        \"package\": \"Flask\",\n        \"version\": \"1.1.2\",\n        \"desc\": \"A micro web framework for Python\"\n    },\n    {\n        \"package\": \"pandas\",\n        \"version\": \"1.2.3\",\n        \"desc\": \"A fast, powerful, flexible, and easy-to-use data analysis and manipulation tool\"\n    },\n    {\n        \"package\": \"numpy\",\n        \"version\": \"1.20.1\",\n        \"desc\": \"Fundamental package for scientific computing\"\n    }\n]"
  },
  {
    "objectID": "reference/pkg.html#pkg.get_pypi_mirror_alias",
    "href": "reference/pkg.html#pkg.get_pypi_mirror_alias",
    "title": "pkg",
    "section": "",
    "text": "get_pypi_mirror_alias(self, context, edit_text)\nGet the available PyPI mirror aliases.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nself\nobject\nThe object instance.\nrequired\n\n\ncontext\n…\nThe context parameter (description missing).\nrequired\n\n\nedit_text\n…\nThe edit_text parameter (description missing).\nrequired\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nkeys_view\nA view object of the available PyPI mirror aliases."
  },
  {
    "objectID": "reference/pkg.html#pkg.install_all_packages",
    "href": "reference/pkg.html#pkg.install_all_packages",
    "title": "pkg",
    "section": "",
    "text": "install_all_packages(pypi_mirror_provider='Default')\nInstall all packages listed in the ‘requirements.txt’ file.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npypi_mirror_provider\nstr, optional\nThe PyPI mirror to use for package installation. Defaults to ‘Default’, which uses the official PyPI repository.\n'Default'\n\n\n\n\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nlist\nA list of tuples containing the installation results for each package.\n\n\n\n\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nInstallationError\nIf there is an error during package installation.\n\n\n\n\n\n\nTo install all packages listed in the ‘requirements.txt’ file, run the following command:\ninstall_all_packages(pypi_mirror_provider='https://pypi.org/simple/')"
  },
  {
    "objectID": "reference/pkg.html#pkg.install_package",
    "href": "reference/pkg.html#pkg.install_package",
    "title": "pkg",
    "section": "",
    "text": "install_package(package, pypi_mirror_provider='Default')\nInstall a Python package and its dependencies using pip.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npackage\nstr\nThe name of the package to install.\nrequired\n\n\npypi_mirror_provider\nstr, optional\nThe name/url of the PyPI mirror provider to use. Default is ‘Default’.\n'Default'\n\n\n\n\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nlist\nA list of tuples containing the command list, return code, stdout, and stderr for each pip command run.\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nValueError\nIf the package name is not provided.\n\n\n\n\n\n\nTo install the package ‘requests’ from the PyPI mirror ‘MyMirror’, use:\ninstall_package('requests', 'MyMirror')"
  },
  {
    "objectID": "reference/pkg.html#pkg.is_available",
    "href": "reference/pkg.html#pkg.is_available",
    "title": "pkg",
    "section": "",
    "text": "is_available(package, version=None)\nCheck if a given package is available with the specified version.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npackage\nstr\nThe name of the package to check.\nrequired\n\n\nversion\nstr, optional\nThe version of the package to check.\nNone\n\n\n\n\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nbool\nTrue if the package with the specified version is available, False otherwise.\n\n\n\n\n\n\n&gt;&gt;&gt; is_available('numpy', '1.20.1')\nTrue"
  },
  {
    "objectID": "reference/pkg.html#pkg.is_current",
    "href": "reference/pkg.html#pkg.is_current",
    "title": "pkg",
    "section": "",
    "text": "is_current(package)\nCheck if the specified package is the current version.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npackage\nstr\nThe name of the package to check.\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nbool\nTrue if the package is the current version, False otherwise."
  },
  {
    "objectID": "reference/pkg.html#pkg.process_pypi_mirror_to_url",
    "href": "reference/pkg.html#pkg.process_pypi_mirror_to_url",
    "title": "pkg",
    "section": "",
    "text": "process_pypi_mirror_to_url(pypi_mirror_provider)\nProcess a PyPI mirror provider and return the corresponding URL.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npypi_mirror_provider\nstr\nThe PyPI mirror provider to process.\nrequired\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nstr\nThe URL of the PyPI mirror.\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nValueError\nIf the provided PyPI mirror provider is invalid."
  },
  {
    "objectID": "reference/pkg.html#pkg.run_python",
    "href": "reference/pkg.html#pkg.run_python",
    "title": "pkg",
    "section": "",
    "text": "run_python(cmd_list=None, mirror_url='', timeout=600)\nRuns pip command using the specified command list and returns the command output.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncmd_list\nlist, optional\nList of pip commands to be executed. Defaults to None.\nNone\n\n\nmirror_url\nstr, optional\nURL of a package repository mirror to be used for the command. Defaults to ’’.\n''\n\n\ntimeout\nint, optional\nTime in seconds to wait for the command to complete. Defaults to 600.\n600\n\n\n\n\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\ntuple\nA tuple containing the command list, command return code, command standard output, and command standard error.\n\n\n\n\n\n\nInstall numpy using pip and print the command output\ncmd_list = [\"-m\", \"pip\", \"install\", \"numpy\"]\nmirror_url = 'https://pypi.org/simple/'\ncmd_output = run_python(cmd_list, mirror_url=mirror_url, timeout=300)\nprint(cmd_output)"
  },
  {
    "objectID": "reference/pkg.html#pkg.start_logging",
    "href": "reference/pkg.html#pkg.start_logging",
    "title": "pkg",
    "section": "",
    "text": "start_logging(logfile_name='side-packages-install')\nConfigure and start logging to a file.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nlogfile_name\nstr, optional\nThe name of the log file. Defaults to ‘side-packages-install’.\n'side-packages-install'\n\n\n\n\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nlogging.Logger\nA Logger object that can be used to write log messages.\n\n\n\nThis function sets up a logging configuration with a specified log file name and logging level. The log file will be created in the ADDON_DIR/logs directory. If the directory does not exist, it will be created. The function returns a Logger object that can be used to write log messages."
  },
  {
    "objectID": "reference/star.html",
    "href": "reference/star.html",
    "title": "star",
    "section": "",
    "text": "``\n\n\n\n\n\nName\nDescription\n\n\n\n\nload_star_file\n\n\n\npanel\n\n\n\n\n\n\n\nload_star_file(file_path, obj_name='NewStarInstances', node_tree=True, world_scale=0.01)\n\n\n\npanel(layout_function, scene)"
  },
  {
    "objectID": "reference/star.html#functions",
    "href": "reference/star.html#functions",
    "title": "star",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nload_star_file\n\n\n\npanel"
  },
  {
    "objectID": "reference/star.html#star.load_star_file",
    "href": "reference/star.html#star.load_star_file",
    "title": "star",
    "section": "",
    "text": "load_star_file(file_path, obj_name='NewStarInstances', node_tree=True, world_scale=0.01)"
  },
  {
    "objectID": "reference/star.html#star.panel",
    "href": "reference/star.html#star.panel",
    "title": "star",
    "section": "",
    "text": "panel(layout_function, scene)"
  },
  {
    "objectID": "reference/assembly.html",
    "href": "reference/assembly.html",
    "title": "assembly",
    "section": "",
    "text": "assembly\n``\nA subpackage for reading rotation matrices and translation vectors for biological assemblies from different file formats.\nThe central functions are get_transformations_"
  },
  {
    "objectID": "reference/nodes.html",
    "href": "reference/nodes.html",
    "title": "nodes",
    "section": "",
    "text": "``\n\n\n\n\n\nName\nDescription\n\n\n\n\nmn_data_file\n\n\n\nsocket_types\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nMN_base_material\nAppend MN_atomic_material to the .blend file it it doesn’t already exist,\n\n\nadd_custom_node_group\n\n\n\nadd_custom_node_group_to_node\n\n\n\nadd_node\n\n\n\nappend\n\n\n\nchain_color\nGiven the input list of chain names, will create a node group which uses\n\n\nchain_selection\nGiven a an input_list, will create a node which takes an Integer input,\n\n\ncreate_assembly_node_tree\n\n\n\ncreate_custom_surface\n\n\n\ncreate_starting_node_tree\n\n\n\ncreate_starting_nodes_density\n\n\n\ncreate_starting_nodes_starfile\n\n\n\ngn_new_group_empty\n\n\n\nnodes_to_geometry\n\n\n\nresid_multiple_selection\nReturns a node group that takes an integer input and creates a boolean\n\n\nsplit_geometry_to_instances\nCreate a Node to Split Geometry by an Attribute into Instances\n\n\n\n\n\n\nMN_base_material()\nAppend MN_atomic_material to the .blend file it it doesn’t already exist, and return that material.\n\n\n\nadd_custom_node_group(parent_group, node_name, location=\\[0, 0\\], width=200, show_options=False, link=False)\n\n\n\nadd_custom_node_group_to_node(parent_group, node_name, location=\\[0, 0\\], width=200, show_options=False, link=False)\n\n\n\nadd_node(node_name, label='', show_options=False)\n\n\n\nappend(node_name, link=False)\n\n\n\nchain_color(node_name, input_list, label_prefix='Chain ', field='chain_id', starting_value=0)\nGiven the input list of chain names, will create a node group which uses the chain_id named attribute to manually set the colours for each of the chains.\n\n\n\nchain_selection(node_name, input_list, attribute='chain_id', starting_value=0, label_prefix='')\nGiven a an input_list, will create a node which takes an Integer input, and has a boolean tick box for each item in the input list. The outputs will be the resulting selection and the inversion of the selection. Can contain a prefix for the resulting labels. Mostly used for constructing chain selections when required for specific proteins.\n\n\n\ncreate_assembly_node_tree(name, iter_list, data_object)\n\n\n\ncreate_custom_surface(name, n_chains)\n\n\n\ncreate_starting_node_tree(obj, coll_frames, starting_style='atoms')\n\n\n\ncreate_starting_nodes_density(obj, threshold=0.8)\n\n\n\ncreate_starting_nodes_starfile(obj)\n\n\n\ngn_new_group_empty(name='Geometry Nodes')\n\n\n\nnodes_to_geometry(this_group, node_list, output='Geometry', join_offset=300)\n\n\n\nresid_multiple_selection(node_name, input_resid_string)\nReturns a node group that takes an integer input and creates a boolean tick box for each item in the input list. Outputs are the selected residues and the inverse selection. Used for constructing chain selections in specific proteins.\n\n\n\nsplit_geometry_to_instances(name, iter_list=('A', 'B', 'C'), attribute='chain_id')\nCreate a Node to Split Geometry by an Attribute into Instances\nSplits the inputted geometry into instances, based on an attribute field. By default this field is the chain_id but this can be selected for any field. Will loop over each item of the list, so a list of arbitrary items that will define how many times to create the required nodes."
  },
  {
    "objectID": "reference/nodes.html#attributes",
    "href": "reference/nodes.html#attributes",
    "title": "nodes",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nmn_data_file\n\n\n\nsocket_types"
  },
  {
    "objectID": "reference/nodes.html#functions",
    "href": "reference/nodes.html#functions",
    "title": "nodes",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nMN_base_material\nAppend MN_atomic_material to the .blend file it it doesn’t already exist,\n\n\nadd_custom_node_group\n\n\n\nadd_custom_node_group_to_node\n\n\n\nadd_node\n\n\n\nappend\n\n\n\nchain_color\nGiven the input list of chain names, will create a node group which uses\n\n\nchain_selection\nGiven a an input_list, will create a node which takes an Integer input,\n\n\ncreate_assembly_node_tree\n\n\n\ncreate_custom_surface\n\n\n\ncreate_starting_node_tree\n\n\n\ncreate_starting_nodes_density\n\n\n\ncreate_starting_nodes_starfile\n\n\n\ngn_new_group_empty\n\n\n\nnodes_to_geometry\n\n\n\nresid_multiple_selection\nReturns a node group that takes an integer input and creates a boolean\n\n\nsplit_geometry_to_instances\nCreate a Node to Split Geometry by an Attribute into Instances"
  },
  {
    "objectID": "reference/nodes.html#nodes.MN_base_material",
    "href": "reference/nodes.html#nodes.MN_base_material",
    "title": "nodes",
    "section": "",
    "text": "MN_base_material()\nAppend MN_atomic_material to the .blend file it it doesn’t already exist, and return that material."
  },
  {
    "objectID": "reference/nodes.html#nodes.add_custom_node_group",
    "href": "reference/nodes.html#nodes.add_custom_node_group",
    "title": "nodes",
    "section": "",
    "text": "add_custom_node_group(parent_group, node_name, location=\\[0, 0\\], width=200, show_options=False, link=False)"
  },
  {
    "objectID": "reference/nodes.html#nodes.add_custom_node_group_to_node",
    "href": "reference/nodes.html#nodes.add_custom_node_group_to_node",
    "title": "nodes",
    "section": "",
    "text": "add_custom_node_group_to_node(parent_group, node_name, location=\\[0, 0\\], width=200, show_options=False, link=False)"
  },
  {
    "objectID": "reference/nodes.html#nodes.add_node",
    "href": "reference/nodes.html#nodes.add_node",
    "title": "nodes",
    "section": "",
    "text": "add_node(node_name, label='', show_options=False)"
  },
  {
    "objectID": "reference/nodes.html#nodes.append",
    "href": "reference/nodes.html#nodes.append",
    "title": "nodes",
    "section": "",
    "text": "append(node_name, link=False)"
  },
  {
    "objectID": "reference/nodes.html#nodes.chain_color",
    "href": "reference/nodes.html#nodes.chain_color",
    "title": "nodes",
    "section": "",
    "text": "chain_color(node_name, input_list, label_prefix='Chain ', field='chain_id', starting_value=0)\nGiven the input list of chain names, will create a node group which uses the chain_id named attribute to manually set the colours for each of the chains."
  },
  {
    "objectID": "reference/nodes.html#nodes.chain_selection",
    "href": "reference/nodes.html#nodes.chain_selection",
    "title": "nodes",
    "section": "",
    "text": "chain_selection(node_name, input_list, attribute='chain_id', starting_value=0, label_prefix='')\nGiven a an input_list, will create a node which takes an Integer input, and has a boolean tick box for each item in the input list. The outputs will be the resulting selection and the inversion of the selection. Can contain a prefix for the resulting labels. Mostly used for constructing chain selections when required for specific proteins."
  },
  {
    "objectID": "reference/nodes.html#nodes.create_assembly_node_tree",
    "href": "reference/nodes.html#nodes.create_assembly_node_tree",
    "title": "nodes",
    "section": "",
    "text": "create_assembly_node_tree(name, iter_list, data_object)"
  },
  {
    "objectID": "reference/nodes.html#nodes.create_custom_surface",
    "href": "reference/nodes.html#nodes.create_custom_surface",
    "title": "nodes",
    "section": "",
    "text": "create_custom_surface(name, n_chains)"
  },
  {
    "objectID": "reference/nodes.html#nodes.create_starting_node_tree",
    "href": "reference/nodes.html#nodes.create_starting_node_tree",
    "title": "nodes",
    "section": "",
    "text": "create_starting_node_tree(obj, coll_frames, starting_style='atoms')"
  },
  {
    "objectID": "reference/nodes.html#nodes.create_starting_nodes_density",
    "href": "reference/nodes.html#nodes.create_starting_nodes_density",
    "title": "nodes",
    "section": "",
    "text": "create_starting_nodes_density(obj, threshold=0.8)"
  },
  {
    "objectID": "reference/nodes.html#nodes.create_starting_nodes_starfile",
    "href": "reference/nodes.html#nodes.create_starting_nodes_starfile",
    "title": "nodes",
    "section": "",
    "text": "create_starting_nodes_starfile(obj)"
  },
  {
    "objectID": "reference/nodes.html#nodes.gn_new_group_empty",
    "href": "reference/nodes.html#nodes.gn_new_group_empty",
    "title": "nodes",
    "section": "",
    "text": "gn_new_group_empty(name='Geometry Nodes')"
  },
  {
    "objectID": "reference/nodes.html#nodes.nodes_to_geometry",
    "href": "reference/nodes.html#nodes.nodes_to_geometry",
    "title": "nodes",
    "section": "",
    "text": "nodes_to_geometry(this_group, node_list, output='Geometry', join_offset=300)"
  },
  {
    "objectID": "reference/nodes.html#nodes.resid_multiple_selection",
    "href": "reference/nodes.html#nodes.resid_multiple_selection",
    "title": "nodes",
    "section": "",
    "text": "resid_multiple_selection(node_name, input_resid_string)\nReturns a node group that takes an integer input and creates a boolean tick box for each item in the input list. Outputs are the selected residues and the inverse selection. Used for constructing chain selections in specific proteins."
  },
  {
    "objectID": "reference/nodes.html#nodes.split_geometry_to_instances",
    "href": "reference/nodes.html#nodes.split_geometry_to_instances",
    "title": "nodes",
    "section": "",
    "text": "split_geometry_to_instances(name, iter_list=('A', 'B', 'C'), attribute='chain_id')\nCreate a Node to Split Geometry by an Attribute into Instances\nSplits the inputted geometry into instances, based on an attribute field. By default this field is the chain_id but this can be selected for any field. Will loop over each item of the list, so a list of arbitrary items that will define how many times to create the required nodes."
  }
]