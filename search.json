[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "What is it?",
    "section": "",
    "text": "Molecular Nodes (MN) is an addon for the 3D modelling & animation program Blender that enables easy import of molecular data such as .pdb & .mmCIF. MN also provides a number of pre-built Geometry Nodes for manipulating and creating animations from the underlying molecular data."
  },
  {
    "objectID": "index.html#features",
    "href": "index.html#features",
    "title": "What is it?",
    "section": "Features:",
    "text": "Features:\n\nDownload structures directly from the PDB using the 4-letter codes\nOpen local .pdb & .mmcif files\nOpen multi-state .pdb files and animate them as trajectories\nOpen molecular dynamics trajectory files such as .xtc & .dcd\nProvides a suite of nodes for artistic manipulation of molecular data inside of Geometry Nodes"
  },
  {
    "objectID": "index.html#getting-started-tutorials",
    "href": "index.html#getting-started-tutorials",
    "title": "What is it?",
    "section": "Getting Started Tutorials",
    "text": "Getting Started Tutorials"
  },
  {
    "objectID": "index.html#examples",
    "href": "index.html#examples",
    "title": "What is it?",
    "section": "Examples",
    "text": "Examples\n\n\n\n\nWell, I‚Äôve finally dipped my toe into Blender because of this tutorial, and am enjoying it so far (except for feeling like a total noob and having to google everything‚Ä¶) Thanks for flagging it up @miekeroth! Pleased with Day 1 progress. https://t.co/ked3VfAnpR pic.twitter.com/eqvmEA0zD0\n\n‚Äî Equinox Graphics (@equinoxgraphics) July 4, 2022\n\n\n\n\nA second video showing how to animate multi-state .pdb files and make them disappear in #blender3d and #geometrynodes with my Molecular Nodes! https://t.co/4j6UxC9241 pic.twitter.com/dwWmg1TmD1\n\n‚Äî Brady Johnston (@bradyajohnston) July 1, 2022\n\n\n\n\nMolecular Nodes is stable enough that I‚Äôve made my first tutorial on how to use it! Watch the video to see how to get started and import proteins into #blender3d and #geometrynodes with a single click!Working towards an animation like this‚Ä¶https://t.co/YRKZe0RWfK pic.twitter.com/0WTAFSmj8k\n\n‚Äî Brady Johnston (@bradyajohnston) June 30, 2022\n\n\n\n\n\nReally starting to like Blender. Spot a bug; bug gets fixed. Epic. So here are some nuclear pore structures I couldn‚Äôt do last week. Thanks @bradyajohnston! cc @jankosinski https://t.co/4TSppW1HY9 pic.twitter.com/fAw53k7KJa\n\n‚Äî Equinox Graphics (@equinoxgraphics) July 11, 2022\n\n\n\n\nCelebrating 1000 followers this week!ü•≥As a ‚ÄòThank You‚Äô, #Render of the week is a fun little animation on my favourite #CryoEM #GPCR structure: The human secretin receptor complex (PDB: 6WZG)üéâBig thanks to @bradyajohnston for creating the awesome MolecularNodes addon #Blender3D pic.twitter.com/VgWewxUh4A\n\n‚Äî PiperProteinProductions (@PiperProteins) June 19, 2022\n\n\n\n\nI have now added support for importing full-blown MD topology & trajectory files, from the likes of GROMACS & CHARMM straight into #blender3d! Along with a few other UI & under-the-hood improvements, download v0.5.15 now!https://t.co/qcu3MWGOUc#geometrynodes #3d pic.twitter.com/ybXc8suIyC\n\n‚Äî Brady Johnston (@bradyajohnston) May 23, 2022"
  },
  {
    "objectID": "nodes.html",
    "href": "nodes.html",
    "title": "Node Documentation",
    "section": "",
    "text": "The MOL_prop_setup node associates all of the different atomic properties with their corresponding atoms in the structure.\n\n\n\nAtoms: mesh vertices or point-cloud that are the XYZ locations of the atoms.\nProperties Collections: The collection that contains the NAME_properties_1 models that were imported alongside the structure.\n\n\n\n\nA boolean switch for each of the atomic properties. By default the properties are enabled, but they can be disable if required to provide a slight performance improvement if not required.\n\n\n\n\nAtoms (mesh vertices or point-cloud): that are the XYZ locations of the atoms, that also have named attributes for each of the atomic properties that were selected for set up.\natomic_number (integer field): integer number corresponding to the atomic number of the atom. Defaults to 0 if atomic_number cannot be determined.\nchain_number (integer field): integer number corresponding to the chain that the atom belongs to. Chains will be sorted into alphabetical order, then given a corresponding integer number starting from 1. Defaults to 0 if chain_number cannot be determined.\natom_name_number (integer field): integer number corresponding to the name of the atom within the structure (‚ÄúCA‚Äù for the alpha carbon). Defaults to 0 if atom_name_number cannot be determined.\nAA_sequence_number (integer field): integer number corresponding to the sequence number of the amino acid in the structure that the atom belongs to. For LYS32 the AA_sequence_number will be 32. Defaults to 0 if AA_sequence_number¬†cannot be determined.\nAA_name (integer field): integer number corresponding to the different residue names. Amino acids are numbered 1-20 based on alphabetical order. See the MOL_sel_AA_name node for the corresponding order.\natom_index (integer field): integer number corresponding to the order of the atom within the structure file.\nB_factor (float field): a float number corresponding to the value that was present in the B factor column, also known as the temperature factor.\nis_backbone (boolean field): a boolean value (TRUE or FALSE, 1 or 0) as to whether or not the atom is part of the backbone of the protein.\nis_alpha_carbon (boolean field): a boolean value (TRUE or FALSE, 1 or 0) as to whether or not the atom is an alpha carbon of the amino acid.\n\n\n\n\n\n\n\n\n\n\n\n\n\nThis node uses the is_alpha_carbon property and the chain_number properties to generate a ribbon-representation of the structure as a mesh. Options are available for the radius, smoothness and the resolution of the ribbon.\n\n\n\nAtoms (mesh vertices or point cloud): atoms that contain at least the is_alpha_carbon¬†named attribute and the chain_number¬†attribute to ensure the ribbons are separated by chain.\n\n\n\n\n\nRibbon (mesh): a mesh that is the ribbon representation of the structure.\nCurve (spline / curve): a curve that goes through all of the alpha carbons in the structure, that is used to build the final ribbon mesh."
  },
  {
    "objectID": "getting-started.html",
    "href": "getting-started.html",
    "title": "Getting Started",
    "section": "",
    "text": "This is a very basic introduction to Molecular Nodes. How to import a protein from the PDB & change the colour and style via editing the node graph. Molecular Nodes and Geometry Nodes in general has a lot more advanced functionality, and I encourage you to watch other YouTube tutorials and spend time playing around with it to see what is possible. Everything that I have achieved so far is through playing around to see what could be done."
  },
  {
    "objectID": "getting-started.html#the-molecularnodes-panel",
    "href": "getting-started.html#the-molecularnodes-panel",
    "title": "Getting Started",
    "section": "The MolecularNodes Panel",
    "text": "The MolecularNodes Panel\n\nClick on the Scene Properties panel, which will show the MolecularNodes panel, which has the buttons and options for downloading and importing protein structures.\nEnter your PDB ID of choice and click on download. This will import the molecular data into Blender, and you will see a new object appear in the Outliner (top right) under the MolecularNodes collection.\n\n\nThe structure is now imported into the scene. While initially the structure will appear as grey points, this is because Blender has a 3D view for working, then a Rendered view for actually rendering with calculated lighting."
  },
  {
    "objectID": "getting-started.html#rendered-view",
    "href": "getting-started.html#rendered-view",
    "title": "Getting Started",
    "section": "Rendered View",
    "text": "Rendered View\n\nClick the ‚ÄòRender Properties‚Äô tab, which has the icon for the back of a camera.\nChange the render engine from EEVEE to Cycles.\nChange the render device from CPU to GPU if applicable. Some computers may not have GPU compute available.\nChange the view to rendered view, which will calculate the lighting for the scene and show all of the atoms."
  },
  {
    "objectID": "getting-started.html#the-grid-and-axes",
    "href": "getting-started.html#the-grid-and-axes",
    "title": "Getting Started",
    "section": "The Grid and Axes",
    "text": "The Grid and Axes\nThis 3D viewport will seem familiar if you have used other programs such as PyMol, ChimeraX & VMD. You can move the camera around just like in those other programs.\nYou can rotate the camera view either using the middle mouse button MMB, or using your touch pad if you are on a laptop. You can also click and drag the axis widget to rotate the camera.\nYou can pan the camera using Shift + MMB\nThe main difference is that you can also manipulate the 3D scene in front of you. You can select objects with a left click of the mouse, and move them around by Grabbing them with the G key.\nThe main actions that you use the 3D Viewport for are:\n\n\nG - Grabbing: Moving an object around in 3D space.\nS - Scaling: Changing the relative size of an object.\nR - Rotating: Rotating the object in 3D space.\n\nIn the 3D viewport, much like in real life, there are 3 axes of possible movement and direction. Inside of Blender they are X Y and Z. X and Y form the flat grid that you see in the viewport, being coloured TODO red and green respectively, while Z is the blue vertical axis. These are labelled and highlighted on the axis widget, which is present in the top right corner of the viewport. This will rotate as you rotate the view, so it can always be used as a reference point.\n\n\n\nThe axis widget, present in the 3D viewport."
  },
  {
    "objectID": "getting-started.html#geometry-nodes-editor",
    "href": "getting-started.html#geometry-nodes-editor",
    "title": "Getting Started",
    "section": "Geometry Nodes Editor",
    "text": "Geometry Nodes Editor\nThis is where we edit the node graph for Molecular Nodes. The node graph is a program you create, that is read and executed by Blender from left to right. Each node performs an action on the geometry that is passed into it, and the result of that action is passed out to the right.\n\nThink of it as creating a set of rules for the computer to follow. You define the rules, and the computer can follow those same rules, even if you start with a different data set.\n\nCombining multiple different nodes you can create protein models and complex 3D scenes. In the example below, there is a node tree which should be present on every new structure imported via MolecularNodes. The atoms and bonds are passed in from the left, the atoms are given a colour based on their element and their chain_id, and then the atoms are styled as atoms, scaling the atom radii to 1.00.\n\nThe starting style MOL_style_atoms_cycles is only visible via inside of the Cycles render engine. You can add other styles manipulate the data through other nodes, by adding them with Shift + A and navigating to the MolecularNodes panel at the bottom. There are several categories of nodes for different animations and styles. You can add the Ribbon Protein node, which will create a ribbon representation based on the alpha carbons in the structure. If there is not colour in the structure, ensure that the node has a material MOL_atomic_material at the bottom of the node."
  },
  {
    "objectID": "getting-started.html#quick-animations",
    "href": "getting-started.html#quick-animations",
    "title": "Getting Started",
    "section": "Quick Animations",
    "text": "Quick Animations\nThere are many ways to quickly create animations inside of Blender and MolecularNodes. One such way is to use the Wiggle node inside of MolecularNodes. This wiggles the amino acid side chains, based on their experimentally-determined B-factor, to give life to the structure. Crystral structures are ultimately static snapshots of a dynamic system, and this is a quick way to bring some of those dynamics back to the structure.\n\n\n\nQuickly adding life to a crystal structure.\n\n\n\n\n\nThe nodes used in the wiggle animation above."
  },
  {
    "objectID": "installation.html",
    "href": "installation.html",
    "title": "Installation",
    "section": "",
    "text": "Download the latest bundled release from the releases page. Don‚Äôt download the GitHub repo itself, as this won‚Äôt install inside of Blender.\n\n\n\n\n\n\nSafari\n\n\n\nWhen downloading on MacOS with Safari, it automatically unzips the file into a MolecularNodes folder. This is extremely unhelpful as Blender requires the .zip file to install the addon. Either download with a different browser, or compress the folder again to MolecularNodes.zip."
  },
  {
    "objectID": "installation.html#installing-the-addon",
    "href": "installation.html#installing-the-addon",
    "title": "Installation",
    "section": "Installing the Addon",
    "text": "Installing the Addon\n\n\n\n\n\n\nWindows Administrator\n\n\n\nIf you are on Windows, you may need to run Blender as Administrator to successfully complete the following installation.\n\n\n\nOpen Preferences Panel\n\nClick `Edit‚Äô -> ‚ÄòPreferences‚Äô or press Cmd +  , on Mac.\n\n\n\n\nClick ‚ÄòInstall‚Äô while in ‚ÄòAdd-ons‚Äô\n\n\n\nSelect MolecularNodes_X.zip\n\nThe X‚Äôs will be the current version number of the add-on."
  },
  {
    "objectID": "installation.html#installing-biotite-mdanalysis",
    "href": "installation.html#installing-biotite-mdanalysis",
    "title": "Installation",
    "section": "Installing Biotite & MDAnalysis",
    "text": "Installing Biotite & MDAnalysis\nTo import different data formats, different python packages are required to be installed. Each python package is responsible for importing a different data format.\n\nBiotite: handles the majority of .pdb / .cif file parsing and downloading from the wwPDB.\nMDAnalysis: enables import of molecular dynamics trajectories from programs such as GROMACS / LAMMPS.\nmrcfile: enables import of electron microscopy densities and EM tomography .map files.\n\nEach of these packages should be fine to be installed by a single click. Blender will freeze for potentially a minute or so during installation. Currently M1 / M2 macs require more complex installation to install MDAnalysis, please see the instructions below. Downloading from the wwPDB and opening local .pdb files with Biotite should work fine without MDAnalysis installed.\n\n\n\n\n\n\nMacOS M1 & M2\n\n\n\n\n\nBlender‚Äôs bundled python is unable to install python packages that require compilation on the user‚Äôs machine. Currently, MDAnalysis is missing a pre-compiled .whl to install, and thus installation will fail on M1 & M2 machines. You can download and pre-compile these packages on your machine yourself, following the below instructions.\nThis is the current fix for M1 / M2 machines, but will be fixed in future releases.\nIn short:\n\nInstall miniconda\nDownload and build the required packages for your system\n\nmkdir ~/MDAnalysis-wheel\ncd MDAnalysis-wheel\nconda create -n wheel-builder python=3.10 cython\nconda activate wheel-builder\npython -m pip wheel MDAnalysis==2.5.0 --cache-dir .\nconda deactivate\n\nInstall the built .whl packages, into Blender‚Äôs bundled python. The path to your\n\nNavigate to your Blender‚Äôs python folder (this is the default path for Blender 3.5)\ncd /Applications/Blender.app/Contents/Resources/3.5/python/bin/\nInstall the cached .whl into the bundled python that came with Blender.\n./python3.10 -m pip install MDAnalysis --cache-dir ~/MDAnalysis-wheel\nThe Install MDAnalysis button should now successfully install the remaining packages.\n\n\n\n\nA message should report the successful installation of each package, with the button changing to Reinstall biotite once MolecularNodes detects the successful installation of the package.\nYou may need to restart Blender after package installation for them to work properly.\nIf you have troubled with installation, search through the issues page for a potential solution. If you can‚Äôt find the solution there, please open a new issue on the GitHub page. Please don‚Äôt just DM or email me directly. It‚Äôs better to do problem solving out in the open, as others might have the same issue or someone other than me may already have a solution!"
  },
  {
    "objectID": "examples.html",
    "href": "examples.html",
    "title": "Examples",
    "section": "",
    "text": "To create the animation of ATP synthase you can morph between separate states of ATP synthase and export them from your favourite molecular graphics program. In this example, we will use ChimeraX.\nUse the following code in ChimeraX‚Äôs console to import and create a morph between the 3 different protein conformations that will create the animation:\nopen 6n2y 6n2z 6n30\nmorph #1,2,3 wrap true\nYou can now play back the animation inside of ChimeraX.\nTo save the animation as a multi-pdb file, use the following code to save the .pdb file:\nsave atp-frames.pdb #4 allCoordsets true\nYou can now open the multi-frame pdb file inside of Molecular Nodes using the ‚ÄòOpen Local File‚Äô tab.\n\nThis example is taken directly from the ChimeraX twitter account:\n\n\nTo morph between 3 conformations of ATP synthase use ChimeraX commands ‚Äúopen 6n2y 6n2z 6n30‚Äù and ‚Äúmorph #1,2,3 wrap true‚Äù. #ChimeraXHowTo pic.twitter.com/2u4Au6Tvpf\n\n‚Äî ChimeraX (@UCSFChimeraX) May 8, 2020"
  },
  {
    "objectID": "examples.html#frames-to-import",
    "href": "examples.html#frames-to-import",
    "title": "Examples",
    "section": "2.1 Frames to Import",
    "text": "2.1 Frames to Import\nIn the frame import options, we can choose which frames from the trajectory to import. Importing every frame (interval = 1 ) will take long time to load, and balloon-out the save-file size of the .blend file. It‚Äôs best to work with some subset of the trajectory frames, and interpolate between them with Molecular Nodes.\n\n\n\n\n\n\n\nNote\n\n\n\nMolecular nodes is still surprisingly performant with thousands of frames loaded, but the .blend file takes a long time to save and load due to several GBs worth of data being save and loaded each time.\n\n\nFor this example we are going to import every 10th frame."
  },
  {
    "objectID": "examples.html#click-import-frames-and-wait",
    "href": "examples.html#click-import-frames-and-wait",
    "title": "Examples",
    "section": "2.2 Click ‚ÄòImport Frames‚Äô and Wait",
    "text": "2.2 Click ‚ÄòImport Frames‚Äô and Wait\nMolecular Nodes is working through a lot of data, so this load step can take a few minutes - be patient. Once it‚Äôs all loaded, the structure along with the atomic properties are available for use inside of Geometry Nodes!"
  },
  {
    "objectID": "examples.html#click-space-to-play-the-animation.",
    "href": "examples.html#click-space-to-play-the-animation.",
    "title": "Examples",
    "section": "2.3 Click space to play the animation.",
    "text": "2.3 Click space to play the animation.\nEnsure to change over to Cycles & rendered view to view the coloured atoms, but otherwise the animation should be playing if press space!\nJust Points\nVideo\nRendered View In this scene I additionally added a Sun light.\nVideo"
  },
  {
    "objectID": "examples.html#geometry-nodes",
    "href": "examples.html#geometry-nodes",
    "title": "Examples",
    "section": "2.4 Geometry Nodes",
    "text": "2.4 Geometry Nodes\nNow that the animation is imported into geometry nodes, you can work with the points as you would otherwise.\nTry applying some noise, or in this example, scaling the points to 0 based on the proximity to an empty.\nVideo"
  },
  {
    "objectID": "documentation.html",
    "href": "documentation.html",
    "title": "Documentation",
    "section": "",
    "text": "When importing a PDB structure, you get a set of interconnected nodes, of which two belong to this addon.\n\nThe MOL_style_color taking for input the geometry, meaning atom coordinates and properties (visible in the top left corner of your blender window). It allows different colors to be assigned based on the value of the atom type attribute. The output is a mesh of vertices (atoms) connected by edges (bonds) that can be converted to a curve.\nYou are free to modify this setup as you wish using the Shift+A shortcut and going to the Molecular Nodes tab, which contains a set of nodes detailed thouroughly here.\n\n\n\n\n\nThe MOL_prop_setup node associates all of the different atomic properties with their corresponding atoms in the structure.\n\n\n\nAtoms: mesh vertices or point-cloud that are the XYZ locations of the atoms.\nProperties Collections: The collection that contains the NAME_properties_1 models that were imported alongside the structure.\n\n\n\n\nA boolean switch for each of the atomic properties. By default the properties are enabled, but they can be disable if required to provide a slight performance improvement if not required.\n\n\n\n\nAtoms (mesh vertices or point-cloud): that are the XYZ locations of the atoms, that also have named attributes for each of the atomic properties that were selected for set up.\natomic_number (integer field): integer number corresponding to the atomic number of the atom. Defaults to 0 if atomic_number cannot be determined.\nchain_number (integer field): integer number corresponding to the chain that the atom belongs to. Chains will be sorted into alphabetical order, then given a corresponding integer number starting from 1. Defaults to 0 if chain_number cannot be determined.\natom_name_number (integer field): integer number corresponding to the name of the atom within the structure (‚ÄúCA‚Äù for the alpha carbon). Defaults to 0 if atom_name_number cannot be determined.\nAA_sequence_number (integer field): integer number corresponding to the sequence number of the amino acid in the structure that the atom belongs to. For LYS32 the AA_sequence_number will be 32. Defaults to 0 if AA_sequence_number¬†cannot be determined.\nAA_name (integer field): integer number corresponding to the different residue names. Amino acids are numbered 1-20 based on alphabetical order. See the MOL_sel_AA_name node for the corresponding order.\natom_index (integer field): integer number corresponding to the order of the atom within the structure file.\nB_factor (float field): a float number corresponding to the value that was present in the B factor column, also known as the temperature factor.\nis_backbone (boolean field): a boolean value (TRUE or FALSE, 1 or 0) as to whether or not the atom is part of the backbone of the protein.\nis_alpha_carbon (boolean field): a boolean value (TRUE or FALSE, 1 or 0) as to whether or not the atom is an alpha carbon of the amino acid.\n\n\n\n\n\n\nFor the next two node categories, a selection can be set using either random/noise values, or an attribute inherent to the atoms, listed above. The styling and coloring nodes will then affect chosen atoms.\n\n\n\n\n\n\n\nThis node uses the is_alpha_carbon property and the chain_number properties to generate a ribbon-representation of the structure as a mesh. Options are available for the radius, smoothness and the resolution of the ribbon.\n\n\n\nAtoms (mesh vertices or point cloud): atoms that contain at least the is_alpha_carbon¬†named attribute and the chain_number¬†attribute to ensure the ribbons are separated by chain.\n\n\n\n\n\nRibbon (mesh): a mesh that is the ribbon representation of the structure.\nCurve (spline / curve): a curve that goes through all of the alpha carbons in the structure, that is used to build the final ribbon mesh.\n\n\n\n\n\n\n\nThis node represents atom coordinates as point clouds (cycles, unrealized geometry) or icospheres (eevee, real geometry). Both can be set to have different radii and the eevee one can be set to a different sphere resolution.\n\n\n\nAtoms (mesh vertices or point cloud): atoms that include the vdw_radii attribute.\n\n\n\n\n\nAtoms : Visible spheres per instances of input atoms, depending on the render engine.\n\n\n\n\n\n\nThis node represents the computed surface of the molecule, based on atom coordinates. The quality involves direct subdivision, for a richer geometry, scale radii boosts the influence of each atomon the rendered surface, probe size adds details, surface smoothing reshapes final geometry by blurring, thus averaging, positions.\n\n\n\nAtoms (mesh vertices or point cloud): atoms that include the vdw_radii attribute.\n\n\n\n\n\nSurface : Actual geometry surrounding the atoms.\nVolume : Blender instance of volume density inside of the computed surface. Can be used to scatter points again, or with a specific shader.\n\n\n\n\n\n\nThis node represents the usual molecular representation of molecules, with atoms as a ball and bonds as sticks. Both radii andresolution can be modified.\n\n\n\nAtoms (mesh vertices or point cloud): atoms that include the vdw_radii, bond_types, pre_bond_index, atomic_number, res_name, chain_id, res_id attributes.\n\n\n\n\n\nSticks : Atom bonds visualised as a straight curve.\nBalls : Atoms visualised as spheres.\nBall and Stick Mesh : The combination of the outputs shown above.\n\n\n\n\n\n\nThe highly anticipated update :O\nThis node represents a common modern illustration of proteins, with alpha helix as a planar corskrew shape, and beta sheet as a stretched cuboid with a triangle-shaped polygon at the end, constituting an arrow.\nRepresentations of helixes can be switched between corkskrew and cylinder, and each shape can be scaled and smoothed using either resolution or subdivisions.\nParameters can be changed locally using geometry nodes, see examples in the documentation/examples.md, and combined with other representations using Join Geometry.\n\n\n\nAtoms (mesh vertices or point cloud): atoms that include the is_alpha_carbon attribute.\n\n\n\n\n\nMesh : Geometry containing the secondary structure representations.\n\n\n\n\n\n\nAfter each style node there is a preview of the default settings on a protein. You can combine further reprensentations to style it as you wish (which combination of nodes is the following representation?)\n\n\n\n\n\n\n\n\n\n\nAtoms : Defining geometry.\n\n\n\n\n\nAtoms : selected atoms are colored.\n\n\n\n\n\n\n\n\nColor : Outputs colors on a scale depending on the atomic_number attribute of the atom.\n\n\n\n\n\n\n\n\nAtoms : Atoms that include the necessary attribute (example : atomic_number for Color by Atomic Number node).\n\n\n\n\n\nAtoms : selected atoms are colored depending on the choosen attribute.\n\n\n\n\n\n\nIts roles are akin to the styling nodes, differing only on the inputs.\n\n\n\n\n\nVolume : A blender volume object that can be generated by the Style Surface (Atoms) Node.\n\n\n\n\n\nGeometry : generated sampled surface in the shape of a mesh corresponding to the volume input, keeping only the Color attribute.\n\n\n\n\n\n\n\n\nVolume : A blender volume object that can be generated by the Style Surface (Atoms) Node.\n\n\n\n\n\nGeometry : generated sampled surface represented as intertwined wires corresponding to the volume input, keeping only the Color attribute.\n\n\n\n\n\n\n\n\nAtoms (mesh vertices or point cloud): atoms that include the Color, b_factor, atomic_number, res_name, chain_number, res_id attributes.\n\n\n\n\n\nColor : The color attribute of the selected input atoms.\nb-factor : The b-factor attribute of the selected input atoms.\natomic_number : The atomic_number attribute of the selected input atoms.\nchain_number : The chain_number attribute of the selected input atoms.\nres_id : The res_id attribute of the selected input atoms.\nres_name : The res_name attribute of the selected input atoms.\n\n\n\n\n\n\n\n\n\n\n\nAtoms (mesh vertices or point cloud): atoms that include the Color, b_factor, atomic_number, res_name, chain_id, res_id, vdw_radii attributes.\n\n\n\n\n\nAtoms : Input atom instances with bonds corresponding to icosphere points distributed around each atoms and with distance inside of the Scale Radius.\n\n\n\n\n\n\n\n\nAtoms (mesh vertices or point cloud): atoms composed of bonded geometry.\n\n\n\n\n\nAtoms : Input atom instances with the resulting bonds with length inside of the Distance Cutoff attribute value.\n\n\n\n\n\n\n\n\nSelection : selected atoms composed of bonded geometry.\n\n\n\n\n\nSelection + Bonded : The input selected atoms in addition to the closely detected atoms linked to it.\nBonded : closely detected atoms with active bond shared with selected atoms.\n\n\n\n\n\n\n\n\n\n\n\nAtoms (mesh vertices or point cloud): atom geometry.\n\n\n\n\n\nSelected Atoms : Atom geometry corresponding to the input selection.\nInverted Atoms : Atoms of the input goemtry not corresponding to the selection.\nPre-Sel.Index : Index attribute of the input atoms.\n\n\n\n\n\nUses the res_name attribute as integer coding to determine which part of the structure is part of canonical biomolecules. Only cover nucleic and amino acids for now.\n\n\n\nAtoms (mesh vertices or point cloud): Atoms with res_name attribute.\n\n\n\n\n\nProtein : Atoms corresponding to the residues part of the 20 common amino acids.\nDNA : Atoms corresponding to double-stranded or desoxyribo nucleic acids.\nRNA : Atoms corresponding to single-stranded or ribo nucleic acids.\nOther : Atoms flagged as exotic residues.\n\n\n\n\n\nUses the chain_id attribute to generate atom selection.\n\n\n\nSelection : Atom selection corresponding to chosen chains.\nInverted : Atom selection opposite from the above.\n\n\n\n\n\nUses the res_name attribute to generate atom selection.\n\n\n\nSelection : Atom selection corresponding to chosen ligand.\nInverted : Atom selection opposite from the above.\n\n\n\n\n\nUses the atom_name attribute to generate atom selection.\n\n\n\nis_alpha_carbon : Atom selection for CA.\nis_backbone : Atom selection for CA, C, O and N.\nis_side_chain : Atom selection for side chain of residues.\n\n\n\n\n\nUses is_alpha_carbon, is_backbone, is_peptide, is_nuleic, is_solvent, is_carb attributes in combination to generate exclusive selections.\n\n\n\nUses atomic_number attribute to select a specific type of atom. Equal to the Z parameter in the periodic table (or proton composition of a nucleus).\n\n\n\nSimilar to the node above, lays out the most common biological atomic components with name and coding for selection.\n\n\n\nBoth Distance and Slice Nodes work the same way, the inputs are foregin objects, and the outputs are selections for the geometry of the molecule imported with Molecular Nodes (aka the information for a specific geometry nodes modifier). In Blender, objects used for constraints and animations are often Empties, objects with no visual instance used to influence other objects‚Äô properties.\nDistance returns the value of the distance between your molecule and the selected object, as well as what‚Äôs inside and outside the Scale Cutoff as an atom selection.\nSlice looks at the position of another object and outputs selections for the molecule based on XYZ axis.\n\n\n\nUses the res_id attribute to generate a selection based on the enumeration ID of residues in the molecuel.\nComposed of the two possibilities, Res Single and Res Range, referencing the selection of a single residue or sevral contiguous at once.\n\n\n\nUses the res_name attribute to generate selection for either amino acids or nucleic acids.\n\n\n\nLets you add the whole molecule selection to the input one (or generates it if no input).\n\n\n\nLets you select specific types of atoms in the backbone and whole backbone or sidechains.\n\n\n\n\nTo replicate trajectories, all the states/frames are loaded in as an object in a collection, and these nodes allow for frame interpolation.\nFor most of the nodes of this category, it is important to place the origin of the geometry in the right place.\nPositions are actualised temporally based on random values or noise, and the Animate 0..1 value drives the progress of the animation, it can be either fed animation value, or it can be keyframed by Blender internal tools.\nThe Wiggle scales with the b_factor attribute, and the Curve redistributes input atoms along the instanced profile curve of choice (will be done relative to coordinates, this is why geometry origin is especially important to get right).\n\n\n\nWhen the PDB file imported contains information about Biological Assemblies (i.e.¬†superstructure polymer for a protein, for example virus capsid), these information can be called upon to realize the assemblies and center them.\n\n\n\nWhen a DNA object is imported, a curve will follow the general path of helix and bases will be instanced in the prim_DNA collection.\n\n\n\n\n\nCurve : input curve where the helix is generated.\nBases : dNTPs in a collection that are instaced on the helix.\n\n\n\n\n\nBase Instances : Rotated instances that can be realized on a curve with Instance on Points (pick instance).\nHelix Curve : The guiding curve for nucleic bases (can be treated as a ‚ÄúPoints‚Äù distribution‚Äù.)\n\n\n\n\n\nPicks base instances from the prim_DNA colection generated on import or on node instancing and colors them.\n\n\n\nWorks essentially the same as for Styling nodes described above, just for bases instead of residues.\n\n\n\n\nNodes used inside other nodes of this addon to facilitate geometry manipulation."
  },
  {
    "objectID": "reference/ui.html",
    "href": "reference/ui.html",
    "title": "Molecular Nodes",
    "section": "",
    "text": "``\n\n\n\n\n\nName\nDescription\n\n\n\n\nMOL_PT_panel_local\n\n\n\nMOL_PT_panel_rcsb\n\n\n\nMOL_PT_panel_ui\n\n\n\nMOL_change_import_interface\n\n\n\ndefault_style\n\n\n\nmenu_chain_selection_custom\n\n\n\nmenu_item_color_chains\n\n\n\nmenu_item_interface\n\n\n\nmenu_item_surface_custom\n\n\n\nmenu_ligand_selection_custom\n\n\n\nmenu_residues_selection_custom\n\n\n\nmol_add_node\n\n\n\nmol_add_node_menu\n\n\n\n\n\n\n\nMOL_PT_panel_local(layout_function)\n\n\n\nMOL_PT_panel_rcsb(layout_function)\n\n\n\nMOL_PT_panel_ui(layout_function, scene)\n\n\n\nMOL_change_import_interface(layout_function, label, interface_value, icon)\n\n\n\ndefault_style(layout, label, panel_display)\n\n\n\nmenu_chain_selection_custom(layout_function)\n\n\n\nmenu_item_color_chains(layout_function, label)\n\n\n\nmenu_item_interface(layout_function, label, node_name, node_description='Add custom MolecularNodes node group.')\n\n\n\nmenu_item_surface_custom(layout_function, label)\n\n\n\nmenu_ligand_selection_custom(layout_function)\n\n\n\nmenu_residues_selection_custom(layout_function)\n\n\n\nmol_add_node(node_name)\n\n\n\nmol_add_node_menu(self, context)"
  },
  {
    "objectID": "reference/density.html",
    "href": "reference/density.html",
    "title": "Molecular Nodes",
    "section": "",
    "text": "``\n\n\n\n\n\nName\nDescription\n\n\n\n\nload\nLoads an MRC file into Blender as a volumetric object.\n\n\nmap_to_grid\nReads an MRC file and converts it into a pyopenvdb FloatGrid object.\n\n\nmap_to_vdb\nConverts an MRC file to a .vdb file using pyopenvdb.\n\n\npanel\n\n\n\npath_to_vdb\n\n\n\nvdb_to_volume\nImports a VDB file as a Blender volume object.\n\n\n\n\n\n\nload(file, name=None, invert=False, world_scale=0.01)\nLoads an MRC file into Blender as a volumetric object.\nArgs: file (str): Path to the MRC file. name (str, optional): If not None, renames the object with the new name. invert (bool): Whether to invert the data from the grid, defaulting to False. Some file types such as EM tomograms have inverted values, where a high value == low density. world_scale (float, optional): Scale of the object in the world. Defaults to 0.01.\nReturns: bpy.types.Object: The loaded volumetric object.\n\n\n\nmap_to_grid(file, invert=False)\nReads an MRC file and converts it into a pyopenvdb FloatGrid object.\nThis function reads a file in MRC format, and converts it into a pyopenvdb FloatGrid object, which can be used to represent volumetric data in Blender.\nArgs: file (str): The path to the MRC file. invert (bool): Whether to invert the data from the grid, defaulting to False. Some file types such as EM tomograms have inverted values, where a high value == low density.\nReturns: pyopenvdb.FloatGrid: A pyopenvdb FloatGrid object containing the density data.\n\n\n\nmap_to_vdb(file, invert=False, world_scale=0.01, overwrite=False)\nConverts an MRC file to a .vdb file using pyopenvdb.\nArgs: file (str): The path to the input MRC file. invert (bool): Whether to invert the data from the grid, defaulting to False. Some file types such as EM tomograms have inverted values, where a high value == low density. world_scale (float, optional): The scaling factor to apply to the voxel size of the input file. Defaults to 0.01. overwrite (bool, optional): If True, the .vdb file will be overwritten if it already exists. Defaults to False.\nReturns: str: The path to the converted .vdb file.\n\n\n\npanel(layout_function, scene)\n\n\n\npath_to_vdb(file)\n\n\n\nvdb_to_volume(file)\nImports a VDB file as a Blender volume object.\nArgs: file (str): Path to the VDB file.\nReturns: bpy.types.Object: A Blender object containing the imported volume data."
  },
  {
    "objectID": "reference/load.html",
    "href": "reference/load.html",
    "title": "Molecular Nodes",
    "section": "",
    "text": "``\n\n\n\n\n\nName\nDescription\n\n\n\n\ncomp_secondary_structure\nUse dihedrals to compute the secondary structure of proteins\n\n\ncreate_molecule\n\n\n\nget_secondary_structure\nGets the secondary structure annotation that is included in mmtf files and returns it as a numerical numpy array.\n\n\nmolecule_local\n\n\n\nmolecule_rcsb\n\n\n\nopen_structure_local_pdb\n\n\n\nopen_structure_local_pdbx\n\n\n\nopen_structure_rcsb\n\n\n\npdb_get_b_factors\nGet a list, which contains a numpy array for each model containing the b-factors.\n\n\n\n\n\n\ncomp_secondary_structure(mol_array)\nUse dihedrals to compute the secondary structure of proteins\nThrough biotite built-in method derivated from P-SEA algorithm (Labesse 1997) Returns an array with secondary structure for each atoms where: - 0 = ‚Äô‚Äô = non-protein or not assigned by biotite annotate_sse - 1 = a = alpha helix - 2 = b = beta sheet - 3 = c = coil\nInspired from https://www.biotite-python.org/examples/gallery/structure/transketolase_sse.html\n\n\n\ncreate_molecule(mol_array, mol_name, center_molecule=False, file=None, calculate_ss=False, del_solvent=False, include_bonds=False, collection=None)\n\n\n\nget_secondary_structure(mol_array, file)\n\n\nmol_array : numpy.array The molecular coordinates array, from mmtf.get_structure() file : mmtf.MMTFFile The MMTF file containing the secondary structure information, from mmtf.MMTFFile.read()\n\n\n\natom_sse : numpy.array Numerical numpy array representing the secondary structure of the molecule.\n\n\n\nThis function uses the biotite.structure package to extract the secondary structure information from the MMTF file. The resulting secondary structures are 1: Alpha Helix, 2: Beta-sheet, 3: loop.\n\n\n\n\nmolecule_local(file_path, mol_name='Name', include_bonds=True, center_molecule=False, del_solvent=True, default_style=0, setup_nodes=True)\n\n\n\nmolecule_rcsb(pdb_code, center_molecule=False, del_solvent=True, include_bonds=True, starting_style=0, setup_nodes=True)\n\n\n\nopen_structure_local_pdb(file_path, include_bonds=True)\n\n\n\nopen_structure_local_pdbx(file_path, include_bonds=True)\n\n\n\nopen_structure_rcsb(pdb_code, include_bonds=True)\n\n\n\npdb_get_b_factors(file)\nGet a list, which contains a numpy array for each model containing the b-factors."
  },
  {
    "objectID": "reference/assembly.html",
    "href": "reference/assembly.html",
    "title": "Molecular Nodes",
    "section": "",
    "text": "``\n\n\n\n\n\nName\nDescription\n\n\n\n\ncreate_assembly_node\n\n\n\ncreate_biological_assembly_node\n\n\n\nget_transformations_mmtf\nreturns a (N, 3, 4) numpy matrix, where N is the number of transformations required\n\n\nget_transformations_pdb\n\n\n\nget_transformations_pdbx\n\n\n\n\n\n\n\ncreate_assembly_node(name, trans_mat)\n\n\n\ncreate_biological_assembly_node(name, transform_dict)\n\n\n\nget_transformations_mmtf(all_assemblies, world_scale=0.01)\nreturns a (N, 3, 4) numpy matrix, where N is the number of transformations required to build out the biological assembly. Currently only extracts and supports the first biological assembly, but this should be straightforward to expand to more assemblies but would require more tweaking with the creation of the nodes themselves than this function\n\n\n\nget_transformations_pdb(file_pdb)\n\n\n\nget_transformations_pdbx(file_pdbx)"
  },
  {
    "objectID": "reference/pkg.html",
    "href": "reference/pkg.html",
    "title": "Molecular Nodes",
    "section": "",
    "text": "``\nHandling installation of external python packages inside of Blender‚Äôs bundled python.\n\n\n\n\n\nName\nDescription\n\n\n\n\nADDON_DIR\nFolder for the addon on the local machine.\n\n\nPYPI_MIRROR\nPossible PyPi mirrors to install from.\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nget_pkgs\nRead a requirements file and extract package information into a dictionary.\n\n\nget_pypi_mirror_alias\nGet the available PyPI mirror aliases.\n\n\ninstall_all_packages\nInstall all packages listed in the ‚Äòrequirements.txt‚Äô file.\n\n\ninstall_package\nInstall a Python package and its dependencies using pip.\n\n\nis_available\nCheck if a given package is available with the specified version.\n\n\nis_current\nCheck if the specified package is the current version.\n\n\nprocess_pypi_mirror_to_url\nProcess a PyPI mirror provider and return the corresponding URL.\n\n\nrun_python\nRuns pip command using the specified command list and returns the command output.\n\n\nstart_logging\nConfigure and start logging to a file.\n\n\n\n\n\n\nget_pkgs(requirements=None)\nRead a requirements file and extract package information into a dictionary.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nrequirements\nstr, optional\nThe path to the requirements file. If not provided, the function looks for a requirements.txt file in the same directory as the script.\nNone\n\n\n\n\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\ndict\nA dictionary containing package information. Each element of the dictionary is a dictionary containing the package name, version, and description.\n\n\n\n\n\n\nGiven the following requirements file:\nFlask==1.1.2 # A micro web framework for Python\npandas==1.2.3 # A fast, powerful, flexible, and easy-to-use data analysis and manipulation tool\nnumpy==1.20.1 # Fundamental package for scientific computing\nThe function would return the following dictionary:\n[\n    {\n        \"package\": \"Flask\",\n        \"version\": \"1.1.2\",\n        \"desc\": \"A micro web framework for Python\"\n    },\n    {\n        \"package\": \"pandas\",\n        \"version\": \"1.2.3\",\n        \"desc\": \"A fast, powerful, flexible, and easy-to-use data analysis and manipulation tool\"\n    },\n    {\n        \"package\": \"numpy\",\n        \"version\": \"1.20.1\",\n        \"desc\": \"Fundamental package for scientific computing\"\n    }\n]\n\n\n\n\nget_pypi_mirror_alias(self, context, edit_text)\nGet the available PyPI mirror aliases.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nself\nobject\nThe object instance.\nrequired\n\n\ncontext\n‚Ä¶\nThe context parameter (description missing).\nrequired\n\n\nedit_text\n‚Ä¶\nThe edit_text parameter (description missing).\nrequired\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nkeys_view\nA view object of the available PyPI mirror aliases.\n\n\n\n\n\n\n\ninstall_all_packages(pypi_mirror_provider='Default')\nInstall all packages listed in the ‚Äòrequirements.txt‚Äô file.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npypi_mirror_provider\nstr, optional\nThe PyPI mirror to use for package installation. Defaults to ‚ÄòDefault‚Äô, which uses the official PyPI repository.\n'Default'\n\n\n\n\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nlist\nA list of tuples containing the installation results for each package.\n\n\n\n\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nInstallationError\nIf there is an error during package installation.\n\n\n\n\n\n\nTo install all packages listed in the ‚Äòrequirements.txt‚Äô file, run the following command:\ninstall_all_packages(pypi_mirror_provider='https://pypi.org/simple/')\n\n\n\n\ninstall_package(package, pypi_mirror_provider='Default')\nInstall a Python package and its dependencies using pip.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npackage\nstr\nThe name of the package to install.\nrequired\n\n\npypi_mirror_provider\nstr, optional\nThe name/url of the PyPI mirror provider to use. Default is ‚ÄòDefault‚Äô.\n'Default'\n\n\n\n\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nlist\nA list of tuples containing the command list, return code, stdout, and stderr for each pip command run.\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nValueError\nIf the package name is not provided.\n\n\n\n\n\n\nTo install the package ‚Äòrequests‚Äô from the PyPI mirror ‚ÄòMyMirror‚Äô, use:\ninstall_package('requests', 'MyMirror')\n\n\n\n\nis_available(package, version=None)\nCheck if a given package is available with the specified version.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npackage\nstr\nThe name of the package to check.\nrequired\n\n\nversion\nstr, optional\nThe version of the package to check.\nNone\n\n\n\n\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nbool\nTrue if the package with the specified version is available, False otherwise.\n\n\n\n\n\n\n>>> is_available('numpy', '1.20.1')\nTrue\n\n\n\n\nis_current(package)\nCheck if the specified package is the current version.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npackage\nstr\nThe name of the package to check.\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nbool\nTrue if the package is the current version, False otherwise.\n\n\n\n\n\n\n\nprocess_pypi_mirror_to_url(pypi_mirror_provider)\nProcess a PyPI mirror provider and return the corresponding URL.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npypi_mirror_provider\nstr\nThe PyPI mirror provider to process.\nrequired\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nstr\nThe URL of the PyPI mirror.\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nValueError\nIf the provided PyPI mirror provider is invalid.\n\n\n\n\n\n\n\nrun_python(cmd_list=None, mirror_url='', timeout=600)\nRuns pip command using the specified command list and returns the command output.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncmd_list\nlist, optional\nList of pip commands to be executed. Defaults to None.\nNone\n\n\nmirror_url\nstr, optional\nURL of a package repository mirror to be used for the command. Defaults to ‚Äô‚Äô.\n''\n\n\ntimeout\nint, optional\nTime in seconds to wait for the command to complete. Defaults to 600.\n600\n\n\n\n\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\ntuple\nA tuple containing the command list, command return code, command standard output, and command standard error.\n\n\n\n\n\n\nInstall numpy using pip and print the command output\ncmd_list = [\"-m\", \"pip\", \"install\", \"numpy\"]\nmirror_url = 'https://pypi.org/simple/'\ncmd_output = run_python(cmd_list, mirror_url=mirror_url, timeout=300)\nprint(cmd_output)\n\n\n\n\nstart_logging(logfile_name='side-packages-install')\nConfigure and start logging to a file.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nlogfile_name\nstr, optional\nThe name of the log file. Defaults to ‚Äòside-packages-install‚Äô.\n'side-packages-install'\n\n\n\n\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nlogging.Logger\nA Logger object that can be used to write log messages.\n\n\n\nThis function sets up a logging configuration with a specified log file name and logging level. The log file will be created in the ADDON_DIR/logs directory. If the directory does not exist, it will be created. The function returns a Logger object that can be used to write log messages."
  },
  {
    "objectID": "reference/star.html",
    "href": "reference/star.html",
    "title": "Molecular Nodes",
    "section": "",
    "text": "``\n\n\n\n\n\nName\nDescription\n\n\n\n\nload_star_file\n\n\n\npanel\n\n\n\n\n\n\n\nload_star_file(file_path, obj_name='NewStarInstances', node_tree=True, world_scale=0.01)\n\n\n\npanel(layout_function, scene)"
  },
  {
    "objectID": "reference/index.html",
    "href": "reference/index.html",
    "title": "Molecular Nodes",
    "section": "",
    "text": "The Python code that powers Molecular Nodes under the hood.\n\n\n\npkg\nHandling installation of external python packages inside of Blender‚Äôs bundled python.\n\n\nload\n\n\n\nnodes\n\n\n\ncoll\n\n\n\ndensity\n\n\n\ndata\n\n\n\nmd\nImporting molecular dynamics trajectories and associated files.\n\n\nstar\n\n\n\nesmfold\n\n\n\nobj\n\n\n\nui\n\n\n\nassembly"
  },
  {
    "objectID": "reference/coll.html",
    "href": "reference/coll.html",
    "title": "Molecular Nodes",
    "section": "",
    "text": "``\n\n\n\n\n\nName\nDescription\n\n\n\n\nframes\nCreate a Collection for Frames of a Trajectory\n\n\nmn\nReturn the MolecularNodes Collection\n\n\n\n\n\n\nframes(name='', parent=None, suffix='_frames')\nCreate a Collection for Frames of a Trajectory\nArgs: name (str, optional): Name of the collection for the frames. Defaults to ‚Äú‚Äú. parent (type, optional): A blender collection which will become the parent collection. Defaults to the MolecularNodes collection if None.\n\n\n\nmn()\nReturn the MolecularNodes Collection\nThe collection called ‚ÄòMolecularNodes‚Äô inside the Blender scene is returned. If the collection does not exist first, it is created."
  },
  {
    "objectID": "reference/data.html",
    "href": "reference/data.html",
    "title": "Molecular Nodes",
    "section": "",
    "text": "``\n\n\n\n\n\nName\nDescription\n\n\n\n\nSACCHARIDE_NAMES\n\n\n\nSACCHARIDE_REPRESENTATION\n\n\n\natom_charge\n\n\n\natom_names\n\n\n\nelements\n\n\n\nlipophobicity\n\n\n\nresidues"
  },
  {
    "objectID": "reference/obj.html",
    "href": "reference/obj.html",
    "title": "Molecular Nodes",
    "section": "",
    "text": "``\n\n\n\n\n\nName\nDescription\n\n\n\n\nadd_attribute\n\n\n\ncreate_object\nCreates a mesh with the given name in the given collection, from the supplied\n\n\nget_attribute\nRetrieve Attribute from Object as Numpy Array\n\n\n\n\n\n\nadd_attribute(object, name, data, type='FLOAT', domain='POINT', add=True)\n\n\n\ncreate_object(name, collection, locations, bonds=\\[\\])\nCreates a mesh with the given name in the given collection, from the supplied values for the locations of vertices, and if supplied, bonds as edges.\n\n\n\nget_attribute(obj, att_name='position')\nRetrieve Attribute from Object as Numpy Array"
  },
  {
    "objectID": "reference/nodes.html",
    "href": "reference/nodes.html",
    "title": "Molecular Nodes",
    "section": "",
    "text": "``\n\n\n\n\n\nName\nDescription\n\n\n\n\nsocket_types\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nadd_custom_node_group\n\n\n\nadd_custom_node_group_to_node\n\n\n\nchain_color\nGiven the input list of chain names, will create a node group which uses\n\n\nchain_selection\nGiven a an input_list, will create a node which takes an Integer input,\n\n\ncreate_custom_surface\n\n\n\ncreate_starting_node_tree\n\n\n\ncreate_starting_nodes_density\n\n\n\ncreate_starting_nodes_starfile\n\n\n\ngn_new_group_empty\n\n\n\nmol_append_node\n\n\n\nmol_base_material\nAppend MOL_atomic_material to the .blend file it it doesn‚Äôt already exist, and return that material.\n\n\nresid_multiple_selection\nReturns a node group that takes an integer input and creates a boolean\n\n\nrotation_matrix\nAdd a Rotation & Translation node from a 3x4 matrix.\n\n\n\n\n\n\nadd_custom_node_group(parent_group, node_name, location=\\[0, 0\\], width=200)\n\n\n\nadd_custom_node_group_to_node(parent_group, node_name, location=\\[0, 0\\], width=200)\n\n\n\nchain_color(node_name, input_list, label_prefix='Chain ')\nGiven the input list of chain names, will create a node group which uses the chain_id named attribute to manually set the colours for each of the chains.\n\n\n\nchain_selection(node_name, input_list, attribute, starting_value=0, label_prefix='')\nGiven a an input_list, will create a node which takes an Integer input, and has a boolean tick box for each item in the input list. The outputs will be the resulting selection and the inversion of the selection. Can contain a prefix for the resulting labels. Mostly used for constructing chain selections when required for specific proteins.\n\n\n\ncreate_custom_surface(name, n_chains)\n\n\n\ncreate_starting_node_tree(obj, coll_frames, starting_style='atoms')\n\n\n\ncreate_starting_nodes_density(obj, threshold=0.8)\n\n\n\ncreate_starting_nodes_starfile(obj)\n\n\n\ngn_new_group_empty(name='Geometry Nodes')\n\n\n\nmol_append_node(node_name)\n\n\n\nmol_base_material()\nAppend MOL_atomic_material to the .blend file it it doesn‚Äôt already exist, and return that material.\n\n\n\nresid_multiple_selection(node_name, input_resid_string)\nReturns a node group that takes an integer input and creates a boolean tick box for each item in the input list. Outputs are the selected residues and the inverse selection. Used for constructing chain selections in specific proteins.\n\n\n\nrotation_matrix(node_group, mat, location=\\[0, 0\\], world_scale=0.01)\nAdd a Rotation & Translation node from a 3x4 matrix.\nArgs: node_group (type): Parent node group to add this new node to. mat (type): 3x4 rotation & translation matrix location (list, optional): Position to add the node in the node tree. Defaults to [0,0]. world_scale(float, optional): Scaling factor for the world. Defaults to 0.01. Returns: type: Newly created node tree."
  },
  {
    "objectID": "reference/esmfold.html",
    "href": "reference/esmfold.html",
    "title": "Molecular Nodes",
    "section": "",
    "text": "``\n\n\n\n\n\nName\nDescription\n\n\n\n\nmolecule_esmfold\n\n\n\nopen_structure_esm_fold\n\n\n\npanel\n\n\n\n\n\n\n\nmolecule_esmfold(amino_acid_sequence, mol_name='Name', center_molecule=False, del_solvent=True, include_bonds=True, starting_style=0, setup_nodes=True)\n\n\n\nopen_structure_esm_fold(amino_acid_sequence, include_bonds=True)\n\n\n\npanel(layout_function)"
  },
  {
    "objectID": "reference/md.html",
    "href": "reference/md.html",
    "title": "Molecular Nodes",
    "section": "",
    "text": "``\nImporting molecular dynamics trajectories and associated files.\n\n\n\n\n\nName\nDescription\n\n\n\n\nload_trajectory\nLoads a molecular dynamics trajectory from the specified files.\n\n\npanel\n\n\n\n\n\n\n\nload_trajectory(file_top, file_traj, name='NewTrajectory', md_start=0, md_end=49, md_step=1, world_scale=0.01, include_bonds=True, selection='not (name H* or name OW)', custom_selections=None)\n\n\nfile_top : str The path to the topology file. file_traj : str The path to the trajectory file. name : str, optional The name of the trajectory (default: ‚Äúdefault‚Äù). md_start : int, optional The starting frame of the trajectory to load (default: 0). md_end : int, optional The ending frame of the trajectory to load (default: 49). md_step : int, optional The step size between frames to load (default: 1). world_scale : float, optional The scaling factor for the world coordinates (default: 0.01). include_bonds : bool, optional Whether to include bond information if available (default: True). selection : str, optional The selection string for atom filtering (default: ‚Äúnot (name H* or name OW)‚Äù). Uses MDAnalysis selection syntax. custom_selections : dict or None, optional A dictionary of custom selections for atom filtering with {‚Äòname‚Äô : ‚Äòselection string‚Äô} (default: None).\n\n\n\nmol_object : bpy.types.Object The loaded topology file as a blender object. coll_frames : bpy.types.Collection The loaded trajectory as a blender collection.\n\n\n\nFileNotFoundError If the topology or trajectory file is not found. IOError If there is an error reading the files.\n\n\n\n\npanel(layout_function, scene)"
  }
]