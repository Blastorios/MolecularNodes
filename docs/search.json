[
  {
    "objectID": "documentation.html",
    "href": "documentation.html",
    "title": "Documentation",
    "section": "",
    "text": "The Molecular Nodes panel can be accessed in the scene properties tab. This panel can additionally be accessed inside the 3D viewport’s N-panel if enabled in the preferences of Molecular Nodes.\n\nThere are currently three methods for importing structures via Molecular Nodes into Blender.\nYou can download from the PDB with the PDB tab, open a local .pdb or .mmcif file with the Local File tab, or open a Molecular Dynamics trajectory on the MD Trajectory tab.\nEach tab has a set of import options and fields to accept PDB IDs, names and file locations.\n\n\n\n\n\nField for the 4-letter PDB ID to be input, and button to start the download and import process.\n\n\n\nWhether or not to try and calculate bond information on the structure during import. Can be very slow for large structures, or if also building a biological assembly. The Cutoff represents the same cutoff value that is used inside of the PyMol bond detection.\n\n\n\nWhether or not to build the biological assembly, such as the full virus capsid, from the symmetry information that is present inside of the file. Assembly ID chooses which assembly information inside of the file to build from.\n\n\n\nInside of structure files, the base unit is usually 1 Å, which will become 1 m inside of Blender and 1 nm will become 10 m. To scale things down to a more manageable size we re-scale the structure so that 1 nm will become 1 m.\n\n\n\n\n\n\n\nAn optional name to be given to the structure on import.\n\n\n\nThe path to the structure file to be opened.\n\n\n\nWhether or not to try and calculate bond information on the structure during import. Can be very slow for large structures, or if also building a biological assembly. The Cutoff represents the same cutoff value that is used inside of the PyMol bond detection.\n\n\n\nWhether or not to build the biological assembly, such as the full virus capsid, from the symmetry information that is present inside of the file. Assembly ID chooses which assembly information inside of the file to build from.\n\n\n\nInside of structure files, the base unit is usually 1 Å, which will become 1 m inside of Blender and 1 nm will become 10 m. To scale things down to a more manageable size we re-scale the structure so that 1 nm will become 1 m.\n\n\n\n\n\n\n\nAn optional name to be given to the structure on import.\n\n\n\nThe file path to the toplogy file for import. See the table of supported topology formats for the formats that should be importable by Molecular Nodes.\n\n\n\nThe file path to the trajectory file for import. See the table of supported trajectory formats for the formats that should be importable by Molecular Nodes.\n\n\n\n\nStart Frame: The first possible frame from the coordinate file to be imported into Blender\nInterval: Imports every n th frame from the trajectory. 1 will import all frames from the trajectory.\nEnd Frame: The last possible frame from the coordinate file to be imported into Blender.\n\n\n\n\nInside of structure files, the base unit is usually 1 Å, which will become 1 m inside of Blender and 1 nm will become 10 m. To scale things down to a more manageable size we re-scale the structure so that 1 nm will become 1 m."
  },
  {
    "objectID": "documentation.html#pdb-tab",
    "href": "documentation.html#pdb-tab",
    "title": "Documentation",
    "section": "",
    "text": "Field for the 4-letter PDB ID to be input, and button to start the download and import process.\n\n\n\nWhether or not to try and calculate bond information on the structure during import. Can be very slow for large structures, or if also building a biological assembly. The Cutoff represents the same cutoff value that is used inside of the PyMol bond detection.\n\n\n\nWhether or not to build the biological assembly, such as the full virus capsid, from the symmetry information that is present inside of the file. Assembly ID chooses which assembly information inside of the file to build from.\n\n\n\nInside of structure files, the base unit is usually 1 Å, which will become 1 m inside of Blender and 1 nm will become 10 m. To scale things down to a more manageable size we re-scale the structure so that 1 nm will become 1 m."
  },
  {
    "objectID": "documentation.html#local-file-tab",
    "href": "documentation.html#local-file-tab",
    "title": "Documentation",
    "section": "",
    "text": "An optional name to be given to the structure on import.\n\n\n\nThe path to the structure file to be opened.\n\n\n\nWhether or not to try and calculate bond information on the structure during import. Can be very slow for large structures, or if also building a biological assembly. The Cutoff represents the same cutoff value that is used inside of the PyMol bond detection.\n\n\n\nWhether or not to build the biological assembly, such as the full virus capsid, from the symmetry information that is present inside of the file. Assembly ID chooses which assembly information inside of the file to build from.\n\n\n\nInside of structure files, the base unit is usually 1 Å, which will become 1 m inside of Blender and 1 nm will become 10 m. To scale things down to a more manageable size we re-scale the structure so that 1 nm will become 1 m."
  },
  {
    "objectID": "documentation.html#md-trajectory-tab",
    "href": "documentation.html#md-trajectory-tab",
    "title": "Documentation",
    "section": "",
    "text": "An optional name to be given to the structure on import.\n\n\n\nThe file path to the toplogy file for import. See the table of supported topology formats for the formats that should be importable by Molecular Nodes.\n\n\n\nThe file path to the trajectory file for import. See the table of supported trajectory formats for the formats that should be importable by Molecular Nodes.\n\n\n\n\nStart Frame: The first possible frame from the coordinate file to be imported into Blender\nInterval: Imports every n th frame from the trajectory. 1 will import all frames from the trajectory.\nEnd Frame: The last possible frame from the coordinate file to be imported into Blender.\n\n\n\n\nInside of structure files, the base unit is usually 1 Å, which will become 1 m inside of Blender and 1 nm will become 10 m. To scale things down to a more manageable size we re-scale the structure so that 1 nm will become 1 m."
  },
  {
    "objectID": "documentation.html#properties",
    "href": "documentation.html#properties",
    "title": "Documentation",
    "section": "2.1 Properties",
    "text": "2.1 Properties\n\n2.1.1 Atomic Properties\nThe MOL_prop_setup node associates all of the different atomic properties with their corresponding atoms in the structure.\n\nRequired Inputs\n\nAtoms: mesh vertices or point-cloud that are the XYZ locations of the atoms.\nProperties Collections: The collection that contains the NAME_properties_1 models that were imported alongside the structure.\n\n\n\nOptional Inputs:\nA boolean switch for each of the atomic properties. By default the properties are enabled, but they can be disable if required to provide a slight performance improvement if not required.\n\n\nOutputs\n\nAtoms (mesh vertices or point-cloud): that are the XYZ locations of the atoms, that also have named attributes for each of the atomic properties that were selected for set up.\natomic_number (integer field): integer number corresponding to the atomic number of the atom. Defaults to 0 if atomic_number cannot be determined.\nchain_number (integer field): integer number corresponding to the chain that the atom belongs to. Chains will be sorted into alphabetical order, then given a corresponding integer number starting from 1. Defaults to 0 if chain_number cannot be determined.\natom_name_number (integer field): integer number corresponding to the name of the atom within the structure (“CA” for the alpha carbon). Defaults to 0 if atom_name_number cannot be determined.\nAA_sequence_number (integer field): integer number corresponding to the sequence number of the amino acid in the structure that the atom belongs to. For LYS32 the AA_sequence_number will be 32. Defaults to 0 if AA_sequence_number cannot be determined.\nAA_name (integer field): integer number corresponding to the different residue names. Amino acids are numbered 1-20 based on alphabetical order. See the MOL_sel_AA_name node for the corresponding order.\natom_index (integer field): integer number corresponding to the order of the atom within the structure file.\nB_factor (float field): a float number corresponding to the value that was present in the B factor column, also known as the temperature factor.\nis_backbone (boolean field): a boolean value (TRUE or FALSE, 1 or 0) as to whether or not the atom is part of the backbone of the protein.\nis_alpha_carbon (boolean field): a boolean value (TRUE or FALSE, 1 or 0) as to whether or not the atom is an alpha carbon of the amino acid."
  },
  {
    "objectID": "documentation.html#styling-nodes",
    "href": "documentation.html#styling-nodes",
    "title": "Documentation",
    "section": "2.2 Styling Nodes",
    "text": "2.2 Styling Nodes\n\n2.2.1 Style Ribbon\nThis node uses the is_alpha_carbon property and the chain_number properties to generate a ribbon-representation of the structure as a mesh. Options are available for the radius, smoothness and the resolution of the ribbon.\n\nRequired Inputs\n\nAtoms (mesh vertices or point cloud): atoms that contain at least the is_alpha_carbon named attribute and the chain_number attribute to ensure the ribbons are separated by chain.\n\n\n\nOutputs\n\nRibbon (mesh): a mesh that is the ribbon representation of the structure.\nCurve (spline / curve): a curve that goes through all of the alpha carbons in the structure, that is used to build the final ribbon mesh."
  },
  {
    "objectID": "examples.html",
    "href": "examples.html",
    "title": "Examples",
    "section": "",
    "text": "To create the animation of ATP synthase you can morph between separate states of ATP synthase and export them from your favourite molecular graphics program. In this example, we will use ChimeraX.\nUse the following code in ChimeraX’s console to import and create a morph between the 3 different protein conformations that will create the animation:\nopen 6n2y 6n2z 6n30\nmorph #1,2,3 wrap true\nYou can now play back the animation inside of ChimeraX.\nTo save the animation as a multi-pdb file, use the following code to save the .pdb file:\nsave atp-frames.pdb #4 allCoordsets true\nYou can now open the multi-frame pdb file inside of Molecular Nodes using the ‘Open Local File’ tab.\n\nThis example is taken directly from the ChimeraX twitter account:\n\n\nTo morph between 3 conformations of ATP synthase use ChimeraX commands “open 6n2y 6n2z 6n30” and “morph #1,2,3 wrap true”. #ChimeraXHowTo pic.twitter.com/2u4Au6Tvpf\n\n— ChimeraX (@UCSFChimeraX) May 8, 2020"
  },
  {
    "objectID": "examples.html#frames-to-import",
    "href": "examples.html#frames-to-import",
    "title": "Examples",
    "section": "2.1 Frames to Import",
    "text": "2.1 Frames to Import\nIn the frame import options, we can choose which frames from the trajectory to import. Importing every frame (interval = 1 ) will take long time to load, and balloon-out the save-file size of the .blend file. It’s best to work with some subset of the trajectory frames, and interpolate between them with Molecular Nodes.\n\n\n\n\n\n\n\nNote\n\n\n\nMolecular nodes is still surprisingly performant with thousands of frames loaded, but the .blend file takes a long time to save and load due to several GBs worth of data being save and loaded each time.\n\n\nFor this example we are going to import every 10th frame."
  },
  {
    "objectID": "examples.html#click-import-frames-and-wait",
    "href": "examples.html#click-import-frames-and-wait",
    "title": "Examples",
    "section": "2.2 Click ‘Import Frames’ and Wait",
    "text": "2.2 Click ‘Import Frames’ and Wait\nMolecular Nodes is working through a lot of data, so this load step can take a few minutes - be patient. Once it’s all loaded, the structure along with the atomic properties are available for use inside of Geometry Nodes!"
  },
  {
    "objectID": "examples.html#click-space-to-play-the-animation.",
    "href": "examples.html#click-space-to-play-the-animation.",
    "title": "Examples",
    "section": "2.3 Click space to play the animation.",
    "text": "2.3 Click space to play the animation.\nEnsure to change over to Cycles & rendered view to view the coloured atoms, but otherwise the animation should be playing if press space!\nJust Points\nVideo\nRendered View In this scene I additionally added a Sun light.\nVideo"
  },
  {
    "objectID": "examples.html#geometry-nodes",
    "href": "examples.html#geometry-nodes",
    "title": "Examples",
    "section": "2.4 Geometry Nodes",
    "text": "2.4 Geometry Nodes\nNow that the animation is imported into geometry nodes, you can work with the points as you would otherwise.\nTry applying some noise, or in this example, scaling the points to 0 based on the proximity to an empty.\nVideo"
  },
  {
    "objectID": "getting-started.html",
    "href": "getting-started.html",
    "title": "Getting Started",
    "section": "",
    "text": "This is a very basic introduction to Molecular Nodes. How to import a protein from the PDB & change the colour and style via editing the node graph. Molecular Nodes and Geometry Nodes in general has a lot more advanced functionality, and I encourage you to watch other YouTube tutorials and spend time playing around with it to see what is possible. Everything that I have achieved so far is through playing around to see what could be done."
  },
  {
    "objectID": "getting-started.html#youtube-tutorials",
    "href": "getting-started.html#youtube-tutorials",
    "title": "Getting Started",
    "section": "YouTube Tutorials",
    "text": "YouTube Tutorials\nI have also made a series of YouTube tutorials walking through some of the functionality of Molecular Nodes. Currently this tutorial series is for the older version of Molecular Nodes and not the 2.0 version. The basic functionality and idea remain the same, but I will be updating this series once I get enough time."
  },
  {
    "objectID": "getting-started.html#the-molecularnodes-panel",
    "href": "getting-started.html#the-molecularnodes-panel",
    "title": "Getting Started",
    "section": "The MolecularNodes Panel",
    "text": "The MolecularNodes Panel\n\nClick on the Scene Properties panel, which will show the MolecularNodes panel, which has the buttons and options for downloading and importing protein structures.\nEnter your PDB ID of choice and click on download. This will import the molecular data into Blender, and you will see a new object appear in the Outliner (top right) under the MolecularNodes collection.\n\n\nThe structure is now imported into the scene. While initially the structure will appear as grey points, this is because Blender has a 3D view for working, then a Rendered view for actually rendering with calculated lighting."
  },
  {
    "objectID": "getting-started.html#rendered-view",
    "href": "getting-started.html#rendered-view",
    "title": "Getting Started",
    "section": "Rendered View",
    "text": "Rendered View\n\nClick the ‘Render Properties’ tab, which has the icon for the back of a camera.\nChange the render engine from EEVEE to Cycles.\nChange the render device from CPU to GPU if applicable. Some computers may not have GPU compute available.\nChange the view to rendered view, which will calculate the lighting for the scene and show all of the atoms."
  },
  {
    "objectID": "getting-started.html#the-grid-and-axes",
    "href": "getting-started.html#the-grid-and-axes",
    "title": "Getting Started",
    "section": "The Grid and Axes",
    "text": "The Grid and Axes\nThis 3D viewport will seem familiar if you have used other programs such as PyMol, ChimeraX & VMD. You can move the camera around just like in those other programs.\nYou can rotate the camera view either using the middle mouse button MMB, or using your touch pad if you are on a laptop. You can also click and drag the axis widget to rotate the camera.\nYou can pan the camera using Shift + MMB\nThe main difference is that you can also manipulate the 3D scene in front of you. You can select objects with a left click of the mouse, and move them around by Grabbing them with the G key.\nThe main actions that you use the 3D Viewport for are:\n\n\nG - Grabbing: Moving an object around in 3D space.\nS - Scaling: Changing the relative size of an object.\nR - Rotating: Rotating the object in 3D space.\n\nIn the 3D viewport, much like in real life, there are 3 axes of possible movement and direction. Inside of Blender they are X Y and Z. X and Y form the flat grid that you see in the viewport, being coloured TODO red and green respectively, while Z is the blue vertical axis. These are labelled and highlighted on the axis widget, which is present in the top right corner of the viewport. This will rotate as you rotate the view, so it can always be used as a reference point.\n\n\n\nThe axis widget, present in the 3D viewport."
  },
  {
    "objectID": "getting-started.html#geometry-nodes-editor",
    "href": "getting-started.html#geometry-nodes-editor",
    "title": "Getting Started",
    "section": "Geometry Nodes Editor",
    "text": "Geometry Nodes Editor\nThis is where we edit the node graph for Molecular Nodes. The node graph is a program you create, that is read and executed by Blender from left to right. Each node performs an action on the geometry that is passed into it, and the result of that action is passed out to the right.\n\nThink of it as creating a set of rules for the computer to follow. You define the rules, and the computer can follow those same rules, even if you start with a different data set.\n\nCombining multiple different nodes you can create protein models and complex 3D scenes. In the example below, there is a node tree which should be present on every new structure imported via MolecularNodes. The atoms and bonds are passed in from the left, the atoms are given a colour based on their element and their chain_id, and then the atoms are styled as atoms, scaling the atom radii to 1.00.\n\nThe starting style MOL_style_atoms_cycles is only visible via inside of the Cycles render engine. You can add other styles manipulate the data through other nodes, by adding them with Shift + A and navigating to the MolecularNodes panel at the bottom. There are several categories of nodes for different animations and styles. You can add the Ribbon Protein node, which will create a ribbon representation based on the alpha carbons in the structure. If there is not colour in the structure, ensure that the node has a material MOL_atomic_material at the bottom of the node."
  },
  {
    "objectID": "getting-started.html#quick-animations",
    "href": "getting-started.html#quick-animations",
    "title": "Getting Started",
    "section": "Quick Animations",
    "text": "Quick Animations\nThere are many ways to quickly create animations inside of Blender and MolecularNodes. One such way is to use the Wiggle node inside of MolecularNodes. This wiggles the amino acid side chains, based on their experimentally-determined B-factor, to give life to the structure. Crystral structures are ultimately static snapshots of a dynamic system, and this is a quick way to bring some of those dynamics back to the structure.\n\n\n\nQuickly adding life to a crystal structure.\n\n\n\n\n\nThe nodes used in the wiggle animation above."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "What is it?",
    "section": "",
    "text": "Molecular Nodes (MN) is an addon for the 3D modelling & animation program Blender that enables easy import of molecular data such as .pdb & .mmCIF. MN also provides a number of pre-built Geometry Nodes for manipulating and creating animations from the underlying molecular data."
  },
  {
    "objectID": "index.html#features",
    "href": "index.html#features",
    "title": "What is it?",
    "section": "Features:",
    "text": "Features:\n\nDownload structures directly from the PDB using the 4-letter codes\nOpen local .pdb & .mmcif files\nOpen multi-state .pdb files and animate them as trajectories\nOpen molecular dynamics trajectory files such as .xtc & .dcd\nProvides a suite of nodes for artistic manipulation of molecular data inside of Geometry Nodes"
  },
  {
    "objectID": "index.html#getting-started-tutorials",
    "href": "index.html#getting-started-tutorials",
    "title": "What is it?",
    "section": "Getting Started Tutorials",
    "text": "Getting Started Tutorials"
  },
  {
    "objectID": "index.html#exmaples",
    "href": "index.html#exmaples",
    "title": "What is it?",
    "section": "Exmaples",
    "text": "Exmaples\n\n\n\n\nWell, I’ve finally dipped my toe into Blender because of this tutorial, and am enjoying it so far (except for feeling like a total noob and having to google everything…) Thanks for flagging it up @miekeroth! Pleased with Day 1 progress. https://t.co/ked3VfAnpR pic.twitter.com/eqvmEA0zD0\n\n— Equinox Graphics (@equinoxgraphics) July 4, 2022\n\n\n\n\nA second video showing how to animate multi-state .pdb files and make them disappear in #blender3d and #geometrynodes with my Molecular Nodes! https://t.co/4j6UxC9241 pic.twitter.com/dwWmg1TmD1\n\n— Brady Johnston (@bradyajohnston) July 1, 2022\n\n\n\n\nMolecular Nodes is stable enough that I’ve made my first tutorial on how to use it! Watch the video to see how to get started and import proteins into #blender3d and #geometrynodes with a single click!Working towards an animation like this…https://t.co/YRKZe0RWfK pic.twitter.com/0WTAFSmj8k\n\n— Brady Johnston (@bradyajohnston) June 30, 2022\n\n\n\n\n\nReally starting to like Blender. Spot a bug; bug gets fixed. Epic. So here are some nuclear pore structures I couldn’t do last week. Thanks @bradyajohnston! cc @jankosinski https://t.co/4TSppW1HY9 pic.twitter.com/fAw53k7KJa\n\n— Equinox Graphics (@equinoxgraphics) July 11, 2022\n\n\n\n\nCelebrating 1000 followers this week!🥳As a ‘Thank You’, #Render of the week is a fun little animation on my favourite #CryoEM #GPCR structure: The human secretin receptor complex (PDB: 6WZG)🎉Big thanks to @bradyajohnston for creating the awesome MolecularNodes addon #Blender3D pic.twitter.com/VgWewxUh4A\n\n— PiperProteinProductions (@PiperProteins) June 19, 2022\n\n\n\n\nI have now added support for importing full-blown MD topology & trajectory files, from the likes of GROMACS & CHARMM straight into #blender3d! Along with a few other UI & under-the-hood improvements, download v0.5.15 now!https://t.co/qcu3MWGOUc#geometrynodes #3d pic.twitter.com/ybXc8suIyC\n\n— Brady Johnston (@bradyajohnston) May 23, 2022"
  },
  {
    "objectID": "installation.html",
    "href": "installation.html",
    "title": "Installation",
    "section": "",
    "text": "Download the latest bundled release from the releases page. Don’t download the GitHub repo itself, as this won’t install inside of Blender.\n\n\n\n\n\n\nSafari\n\n\n\nWhen downloading on MacOS with Safari, it automatically unzips the file into a MolecularNodes folder. This is extremely unhelpful as Blender requires the .zip file to install the addon. Either download with a different browser, or compress the folder again to MolecularNodes.zip."
  },
  {
    "objectID": "installation.html#downloading-molecularnodes",
    "href": "installation.html#downloading-molecularnodes",
    "title": "Installation",
    "section": "",
    "text": "Download the latest bundled release from the releases page. Don’t download the GitHub repo itself, as this won’t install inside of Blender.\n\n\n\n\n\n\nSafari\n\n\n\nWhen downloading on MacOS with Safari, it automatically unzips the file into a MolecularNodes folder. This is extremely unhelpful as Blender requires the .zip file to install the addon. Either download with a different browser, or compress the folder again to MolecularNodes.zip."
  },
  {
    "objectID": "installation.html#installing-the-addon",
    "href": "installation.html#installing-the-addon",
    "title": "Installation",
    "section": "Installing the Addon",
    "text": "Installing the Addon\n\n\n\n\n\n\nWindows Administrator\n\n\n\nIf you are on Windows, you may need to run Blender as Administrator to successfully complete the following installation.\n\n\n\nOpen Preferences Panel\n\nClick `Edit’ -&gt; ‘Preferences’ or press Cmd +  , on Mac.\n\n\n\n\nClick ‘Install’ while in ‘Add-ons’\n\n\n\nSelect MolecularNodes_X.zip\n\nThe X’s will be the current version number of the add-on."
  },
  {
    "objectID": "installation.html#installing-biotite-mdanalysis",
    "href": "installation.html#installing-biotite-mdanalysis",
    "title": "Installation",
    "section": "Installing Biotite & MDAnalysis",
    "text": "Installing Biotite & MDAnalysis\nTo import different data formats, different python packages are required to be installed. Each python package is responsible for importing a different data format.\n\nBiotite: handles the majority of .pdb / .cif file parsing and downloading from the wwPDB.\nMDAnalysis: enables import of molecular dynamics trajectories from programs such as GROMACS / LAMMPS.\nmrcfile: enables import of electron microscopy densities and EM tomography .map files.\n\nEach of these packages should be fine to be installed by a single click. Blender will freeze for potentially a minute or so during installation. Currently M1 / M2 macs require more complex installation to install MDAnalysis, please see the instructions below. Downloading from the wwPDB and opening local .pdb files with Biotite should work fine without MDAnalysis installed.\n\n\n\n\n\n\nMacOS M1 & M2\n\n\n\n\n\nBlender’s bundled python is unable to install python packages that require compilation on the user’s machine. Currently, MDAnalysis is missing a pre-compiled .whl to install, and thus installation will fail on M1 & M2 machines. You can download and pre-compile these packages on your machine yourself, following the below instructions.\nThis is the current fix for M1 / M2 machines, but will be fixed in future releases.\nIn short:\n\nInstall miniconda\nDownload and build the required pacakges for your system\n\nmkdir ~/MDAnalysis-wheel\ncd MDAnalysis-wheel\nconda create -n wheel-builder python=3.10 cython\nconda activate wheel-builder\npython -m pip wheel MDAnalysis==2.2.0 --cache-dir .\nconda deactivate\n\nInstall the built .whl packages, into Blender’s bundled python. The path to your\n\nNavigate to your Blender’s python folder (this is the path for Blender 3.5)\ncd /Applications/Blender.app/Contents/Resources/3.5/python/bin/\nInstall the cached .whl into the bundled python that came with Blender.\n./python3.10 -m pip install MDAnalysis --cache-dir ~/MDAnalysis-wheel\nThe Install Packages button should now successfully install the remaining packages.\n\n\n\n\nA message should report the successful installation of each package, with the button changing to Reinstall biotite once MolecularNodes detects the successful installation of the package.\nIf you have troubled with installation, search through the issues page for a potential solution. If you can’t find the solution there, please open a new issue on the GitHub page. Please don’t just DM or email me directly. It’s better to do problem solving out in the open, as others might have the same issue or someone other than me may already have a solution!"
  },
  {
    "objectID": "nodes.html",
    "href": "nodes.html",
    "title": "Node Documentation",
    "section": "",
    "text": "The MOL_prop_setup node associates all of the different atomic properties with their corresponding atoms in the structure.\n\n\n\nAtoms: mesh vertices or point-cloud that are the XYZ locations of the atoms.\nProperties Collections: The collection that contains the NAME_properties_1 models that were imported alongside the structure.\n\n\n\n\nA boolean switch for each of the atomic properties. By default the properties are enabled, but they can be disable if required to provide a slight performance improvement if not required.\n\n\n\n\nAtoms (mesh vertices or point-cloud): that are the XYZ locations of the atoms, that also have named attributes for each of the atomic properties that were selected for set up.\natomic_number (integer field): integer number corresponding to the atomic number of the atom. Defaults to 0 if atomic_number cannot be determined.\nchain_number (integer field): integer number corresponding to the chain that the atom belongs to. Chains will be sorted into alphabetical order, then given a corresponding integer number starting from 1. Defaults to 0 if chain_number cannot be determined.\natom_name_number (integer field): integer number corresponding to the name of the atom within the structure (“CA” for the alpha carbon). Defaults to 0 if atom_name_number cannot be determined.\nAA_sequence_number (integer field): integer number corresponding to the sequence number of the amino acid in the structure that the atom belongs to. For LYS32 the AA_sequence_number will be 32. Defaults to 0 if AA_sequence_number cannot be determined.\nAA_name (integer field): integer number corresponding to the different residue names. Amino acids are numbered 1-20 based on alphabetical order. See the MOL_sel_AA_name node for the corresponding order.\natom_index (integer field): integer number corresponding to the order of the atom within the structure file.\nB_factor (float field): a float number corresponding to the value that was present in the B factor column, also known as the temperature factor.\nis_backbone (boolean field): a boolean value (TRUE or FALSE, 1 or 0) as to whether or not the atom is part of the backbone of the protein.\nis_alpha_carbon (boolean field): a boolean value (TRUE or FALSE, 1 or 0) as to whether or not the atom is an alpha carbon of the amino acid.\n\n\n\n\n\n\n\n\n\n\n\n\n\nThis node uses the is_alpha_carbon property and the chain_number properties to generate a ribbon-representation of the structure as a mesh. Options are available for the radius, smoothness and the resolution of the ribbon.\n\n\n\nAtoms (mesh vertices or point cloud): atoms that contain at least the is_alpha_carbon named attribute and the chain_number attribute to ensure the ribbons are separated by chain.\n\n\n\n\n\nRibbon (mesh): a mesh that is the ribbon representation of the structure.\nCurve (spline / curve): a curve that goes through all of the alpha carbons in the structure, that is used to build the final ribbon mesh."
  },
  {
    "objectID": "nodes.html#properties",
    "href": "nodes.html#properties",
    "title": "Node Documentation",
    "section": "",
    "text": "The MOL_prop_setup node associates all of the different atomic properties with their corresponding atoms in the structure.\n\n\n\nAtoms: mesh vertices or point-cloud that are the XYZ locations of the atoms.\nProperties Collections: The collection that contains the NAME_properties_1 models that were imported alongside the structure.\n\n\n\n\nA boolean switch for each of the atomic properties. By default the properties are enabled, but they can be disable if required to provide a slight performance improvement if not required.\n\n\n\n\nAtoms (mesh vertices or point-cloud): that are the XYZ locations of the atoms, that also have named attributes for each of the atomic properties that were selected for set up.\natomic_number (integer field): integer number corresponding to the atomic number of the atom. Defaults to 0 if atomic_number cannot be determined.\nchain_number (integer field): integer number corresponding to the chain that the atom belongs to. Chains will be sorted into alphabetical order, then given a corresponding integer number starting from 1. Defaults to 0 if chain_number cannot be determined.\natom_name_number (integer field): integer number corresponding to the name of the atom within the structure (“CA” for the alpha carbon). Defaults to 0 if atom_name_number cannot be determined.\nAA_sequence_number (integer field): integer number corresponding to the sequence number of the amino acid in the structure that the atom belongs to. For LYS32 the AA_sequence_number will be 32. Defaults to 0 if AA_sequence_number cannot be determined.\nAA_name (integer field): integer number corresponding to the different residue names. Amino acids are numbered 1-20 based on alphabetical order. See the MOL_sel_AA_name node for the corresponding order.\natom_index (integer field): integer number corresponding to the order of the atom within the structure file.\nB_factor (float field): a float number corresponding to the value that was present in the B factor column, also known as the temperature factor.\nis_backbone (boolean field): a boolean value (TRUE or FALSE, 1 or 0) as to whether or not the atom is part of the backbone of the protein.\nis_alpha_carbon (boolean field): a boolean value (TRUE or FALSE, 1 or 0) as to whether or not the atom is an alpha carbon of the amino acid."
  },
  {
    "objectID": "nodes.html#styling-nodes",
    "href": "nodes.html#styling-nodes",
    "title": "Node Documentation",
    "section": "",
    "text": "This node uses the is_alpha_carbon property and the chain_number properties to generate a ribbon-representation of the structure as a mesh. Options are available for the radius, smoothness and the resolution of the ribbon.\n\n\n\nAtoms (mesh vertices or point cloud): atoms that contain at least the is_alpha_carbon named attribute and the chain_number attribute to ensure the ribbons are separated by chain.\n\n\n\n\n\nRibbon (mesh): a mesh that is the ribbon representation of the structure.\nCurve (spline / curve): a curve that goes through all of the alpha carbons in the structure, that is used to build the final ribbon mesh."
  },
  {
    "objectID": "reference/coll.html",
    "href": "reference/coll.html",
    "title": "coll",
    "section": "",
    "text": "``\n\n\n\n\n\nName\nDescription\n\n\n\n\nframes\nCreate a Collection for Frames of a Trajectory\n\n\nmn\nReturn the MolecularNodes Collection\n\n\n\n\n\n\nframes(name='', parent=None, suffix='_frames')\nCreate a Collection for Frames of a Trajectory\nArgs: name (str, optional): Name of the collection for the frames. Defaults to ““. parent (type, optional): A blender collection which will become the parent collection. Defaults to the MolecularNodes collection if None.\n\n\n\nmn()\nReturn the MolecularNodes Collection\nThe collection called ‘MolecularNodes’ inside the Blender scene is returned. If the collection does not exist first, it is created."
  },
  {
    "objectID": "reference/coll.html#functions",
    "href": "reference/coll.html#functions",
    "title": "coll",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nframes\nCreate a Collection for Frames of a Trajectory\n\n\nmn\nReturn the MolecularNodes Collection"
  },
  {
    "objectID": "reference/coll.html#coll.frames",
    "href": "reference/coll.html#coll.frames",
    "title": "coll",
    "section": "",
    "text": "frames(name='', parent=None, suffix='_frames')\nCreate a Collection for Frames of a Trajectory\nArgs: name (str, optional): Name of the collection for the frames. Defaults to ““. parent (type, optional): A blender collection which will become the parent collection. Defaults to the MolecularNodes collection if None."
  },
  {
    "objectID": "reference/coll.html#coll.mn",
    "href": "reference/coll.html#coll.mn",
    "title": "coll",
    "section": "",
    "text": "mn()\nReturn the MolecularNodes Collection\nThe collection called ‘MolecularNodes’ inside the Blender scene is returned. If the collection does not exist first, it is created."
  },
  {
    "objectID": "reference/index.html",
    "href": "reference/index.html",
    "title": "Function reference",
    "section": "",
    "text": "The Python code that powers Molecular Nodes under the hood.\n\n\n\npkg\nHandling installation of external python packages inside of Blender’s bundled python.\n\n\nload\n\n\n\nnodes\n\n\n\ncoll"
  },
  {
    "objectID": "reference/index.html#python-api",
    "href": "reference/index.html#python-api",
    "title": "Function reference",
    "section": "",
    "text": "The Python code that powers Molecular Nodes under the hood.\n\n\n\npkg\nHandling installation of external python packages inside of Blender’s bundled python.\n\n\nload\n\n\n\nnodes\n\n\n\ncoll"
  },
  {
    "objectID": "reference/load.html",
    "href": "reference/load.html",
    "title": "load",
    "section": "",
    "text": "``\n\n\n\n\n\nName\nDescription\n\n\n\n\nadd_attribute\n\n\n\ncomp_secondary_structure\nUse dihedrals to compute the secondary structure of proteins\n\n\ncreate_molecule\n\n\n\ncreate_object\nCreates a mesh with the given name in the given collection, from the supplied\n\n\nget_secondary_structure\nGets the secondary structure annotation that is included in mmtf files and returns it as a numerical numpy array.\n\n\nload_star_file\n\n\n\nmolecule_esmfold\n\n\n\nmolecule_local\n\n\n\nmolecule_rcsb\n\n\n\nopen_structure_esm_fold\n\n\n\nopen_structure_local_pdb\n\n\n\nopen_structure_local_pdbx\n\n\n\nopen_structure_rcsb\n\n\n\npdb_get_b_factors\nGet a list, which contains a numpy array for each model containing the b-factors.\n\n\n\n\n\n\nadd_attribute(object, name, data, type='FLOAT', domain='POINT', add=True)\n\n\n\ncomp_secondary_structure(mol_array)\nUse dihedrals to compute the secondary structure of proteins\nThrough biotite built-in method derivated from P-SEA algorithm (Labesse 1997) Returns an array with secondary structure for each atoms where: - 0 = ’’ = non-protein or not assigned by biotite annotate_sse - 1 = a = alpha helix - 2 = b = beta sheet - 3 = c = coil\nInspired from https://www.biotite-python.org/examples/gallery/structure/transketolase_sse.html\n\n\n\ncreate_molecule(mol_array, mol_name, center_molecule=False, file=None, calculate_ss=False, del_solvent=False, include_bonds=False, collection=None)\n\n\n\ncreate_object(name, collection, locations, bonds=\\[\\])\nCreates a mesh with the given name in the given collection, from the supplied values for the locations of vertices, and if supplied, bonds as edges.\n\n\n\nget_secondary_structure(mol_array, file)\n\n\nmol_array : numpy.array The molecular coordinates array, from mmtf.get_structure() file : mmtf.MMTFFile The MMTF file containing the secondary structure information, from mmtf.MMTFFile.read()\n\n\n\natom_sse : numpy.array Numerical numpy array representing the secondary structure of the molecule.\n\n\n\nThis function uses the biotite.structure package to extract the secondary structure information from the MMTF file. The resulting secondary structures are 1: Alpha Helix, 2: Beta-sheet, 3: loop.\n\n\n\n\nload_star_file(file_path, obj_name='NewStarInstances', node_tree=True, world_scale=0.01)\n\n\n\nmolecule_esmfold(amino_acid_sequence, mol_name='Name', center_molecule=False, del_solvent=True, include_bonds=True, starting_style=0, setup_nodes=True)\n\n\n\nmolecule_local(file_path, mol_name='Name', include_bonds=True, center_molecule=False, del_solvent=True, default_style=0, setup_nodes=True)\n\n\n\nmolecule_rcsb(pdb_code, center_molecule=False, del_solvent=True, include_bonds=True, starting_style=0, setup_nodes=True)\n\n\n\nopen_structure_esm_fold(amino_acid_sequence, include_bonds=True)\n\n\n\nopen_structure_local_pdb(file_path, include_bonds=True)\n\n\n\nopen_structure_local_pdbx(file_path, include_bonds=True)\n\n\n\nopen_structure_rcsb(pdb_code, include_bonds=True)\n\n\n\npdb_get_b_factors(file)\nGet a list, which contains a numpy array for each model containing the b-factors."
  },
  {
    "objectID": "reference/load.html#functions",
    "href": "reference/load.html#functions",
    "title": "load",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nadd_attribute\n\n\n\ncomp_secondary_structure\nUse dihedrals to compute the secondary structure of proteins\n\n\ncreate_molecule\n\n\n\ncreate_object\nCreates a mesh with the given name in the given collection, from the supplied\n\n\nget_secondary_structure\nGets the secondary structure annotation that is included in mmtf files and returns it as a numerical numpy array.\n\n\nload_star_file\n\n\n\nmolecule_esmfold\n\n\n\nmolecule_local\n\n\n\nmolecule_rcsb\n\n\n\nopen_structure_esm_fold\n\n\n\nopen_structure_local_pdb\n\n\n\nopen_structure_local_pdbx\n\n\n\nopen_structure_rcsb\n\n\n\npdb_get_b_factors\nGet a list, which contains a numpy array for each model containing the b-factors."
  },
  {
    "objectID": "reference/load.html#load.add_attribute",
    "href": "reference/load.html#load.add_attribute",
    "title": "load",
    "section": "",
    "text": "add_attribute(object, name, data, type='FLOAT', domain='POINT', add=True)"
  },
  {
    "objectID": "reference/load.html#load.comp_secondary_structure",
    "href": "reference/load.html#load.comp_secondary_structure",
    "title": "load",
    "section": "",
    "text": "comp_secondary_structure(mol_array)\nUse dihedrals to compute the secondary structure of proteins\nThrough biotite built-in method derivated from P-SEA algorithm (Labesse 1997) Returns an array with secondary structure for each atoms where: - 0 = ’’ = non-protein or not assigned by biotite annotate_sse - 1 = a = alpha helix - 2 = b = beta sheet - 3 = c = coil\nInspired from https://www.biotite-python.org/examples/gallery/structure/transketolase_sse.html"
  },
  {
    "objectID": "reference/load.html#load.create_molecule",
    "href": "reference/load.html#load.create_molecule",
    "title": "load",
    "section": "",
    "text": "create_molecule(mol_array, mol_name, center_molecule=False, file=None, calculate_ss=False, del_solvent=False, include_bonds=False, collection=None)"
  },
  {
    "objectID": "reference/load.html#load.create_object",
    "href": "reference/load.html#load.create_object",
    "title": "load",
    "section": "",
    "text": "create_object(name, collection, locations, bonds=\\[\\])\nCreates a mesh with the given name in the given collection, from the supplied values for the locations of vertices, and if supplied, bonds as edges."
  },
  {
    "objectID": "reference/load.html#load.get_secondary_structure",
    "href": "reference/load.html#load.get_secondary_structure",
    "title": "load",
    "section": "",
    "text": "get_secondary_structure(mol_array, file)\n\n\nmol_array : numpy.array The molecular coordinates array, from mmtf.get_structure() file : mmtf.MMTFFile The MMTF file containing the secondary structure information, from mmtf.MMTFFile.read()\n\n\n\natom_sse : numpy.array Numerical numpy array representing the secondary structure of the molecule.\n\n\n\nThis function uses the biotite.structure package to extract the secondary structure information from the MMTF file. The resulting secondary structures are 1: Alpha Helix, 2: Beta-sheet, 3: loop."
  },
  {
    "objectID": "reference/load.html#load.load_star_file",
    "href": "reference/load.html#load.load_star_file",
    "title": "load",
    "section": "",
    "text": "load_star_file(file_path, obj_name='NewStarInstances', node_tree=True, world_scale=0.01)"
  },
  {
    "objectID": "reference/load.html#load.molecule_esmfold",
    "href": "reference/load.html#load.molecule_esmfold",
    "title": "load",
    "section": "",
    "text": "molecule_esmfold(amino_acid_sequence, mol_name='Name', center_molecule=False, del_solvent=True, include_bonds=True, starting_style=0, setup_nodes=True)"
  },
  {
    "objectID": "reference/load.html#load.molecule_local",
    "href": "reference/load.html#load.molecule_local",
    "title": "load",
    "section": "",
    "text": "molecule_local(file_path, mol_name='Name', include_bonds=True, center_molecule=False, del_solvent=True, default_style=0, setup_nodes=True)"
  },
  {
    "objectID": "reference/load.html#load.molecule_rcsb",
    "href": "reference/load.html#load.molecule_rcsb",
    "title": "load",
    "section": "",
    "text": "molecule_rcsb(pdb_code, center_molecule=False, del_solvent=True, include_bonds=True, starting_style=0, setup_nodes=True)"
  },
  {
    "objectID": "reference/load.html#load.open_structure_esm_fold",
    "href": "reference/load.html#load.open_structure_esm_fold",
    "title": "load",
    "section": "",
    "text": "open_structure_esm_fold(amino_acid_sequence, include_bonds=True)"
  },
  {
    "objectID": "reference/load.html#load.open_structure_local_pdb",
    "href": "reference/load.html#load.open_structure_local_pdb",
    "title": "load",
    "section": "",
    "text": "open_structure_local_pdb(file_path, include_bonds=True)"
  },
  {
    "objectID": "reference/load.html#load.open_structure_local_pdbx",
    "href": "reference/load.html#load.open_structure_local_pdbx",
    "title": "load",
    "section": "",
    "text": "open_structure_local_pdbx(file_path, include_bonds=True)"
  },
  {
    "objectID": "reference/load.html#load.open_structure_rcsb",
    "href": "reference/load.html#load.open_structure_rcsb",
    "title": "load",
    "section": "",
    "text": "open_structure_rcsb(pdb_code, include_bonds=True)"
  },
  {
    "objectID": "reference/load.html#load.pdb_get_b_factors",
    "href": "reference/load.html#load.pdb_get_b_factors",
    "title": "load",
    "section": "",
    "text": "pdb_get_b_factors(file)\nGet a list, which contains a numpy array for each model containing the b-factors."
  },
  {
    "objectID": "reference/nodes.html",
    "href": "reference/nodes.html",
    "title": "nodes",
    "section": "",
    "text": "``\n\n\n\n\n\nName\nDescription\n\n\n\n\nsocket_types\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nadd_custom_node_group\n\n\n\nadd_custom_node_group_to_node\n\n\n\nchain_color\nGiven the input list of chain names, will create a node group which uses\n\n\nchain_selection\nGiven a an input_list, will create a node which takes an Integer input,\n\n\ncreate_custom_surface\n\n\n\ncreate_starting_node_tree\n\n\n\ncreate_starting_nodes_density\n\n\n\ncreate_starting_nodes_starfile\n\n\n\ngn_new_group_empty\n\n\n\nmol_append_node\n\n\n\nmol_base_material\nAppend MOL_atomic_material to the .blend file it it doesn’t already exist, and return that material.\n\n\nresid_multiple_selection\nReturns a node group that takes an integer input and creates a boolean\n\n\nrotation_matrix\nAdd a Rotation & Translation node from a 3x4 matrix.\n\n\n\n\n\n\nadd_custom_node_group(parent_group, node_name, location=\\[0, 0\\], width=200)\n\n\n\nadd_custom_node_group_to_node(parent_group, node_name, location=\\[0, 0\\], width=200)\n\n\n\nchain_color(node_name, input_list, label_prefix='Chain ')\nGiven the input list of chain names, will create a node group which uses the chain_id named attribute to manually set the colours for each of the chains.\n\n\n\nchain_selection(node_name, input_list, attribute, starting_value=0, label_prefix='')\nGiven a an input_list, will create a node which takes an Integer input, and has a boolean tick box for each item in the input list. The outputs will be the resulting selection and the inversion of the selection. Can contain a prefix for the resulting labels. Mostly used for constructing chain selections when required for specific proteins.\n\n\n\ncreate_custom_surface(name, n_chains)\n\n\n\ncreate_starting_node_tree(obj, coll_frames, starting_style='atoms')\n\n\n\ncreate_starting_nodes_density(obj)\n\n\n\ncreate_starting_nodes_starfile(obj)\n\n\n\ngn_new_group_empty(name='Geometry Nodes')\n\n\n\nmol_append_node(node_name)\n\n\n\nmol_base_material()\nAppend MOL_atomic_material to the .blend file it it doesn’t already exist, and return that material.\n\n\n\nresid_multiple_selection(node_name, input_resid_string)\nReturns a node group that takes an integer input and creates a boolean tick box for each item in the input list. Outputs are the selected residues and the inverse selection. Used for constructing chain selections in specific proteins.\n\n\n\nrotation_matrix(node_group, mat, location=\\[0, 0\\], world_scale=0.01)\nAdd a Rotation & Translation node from a 3x4 matrix.\nArgs: node_group (type): Parent node group to add this new node to. mat (type): 3x4 rotation & translation matrix location (list, optional): Position to add the node in the node tree. Defaults to [0,0]. world_scale(float, optional): Scaling factor for the world. Defaults to 0.01. Returns: type: Newly created node tree."
  },
  {
    "objectID": "reference/nodes.html#attributes",
    "href": "reference/nodes.html#attributes",
    "title": "nodes",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nsocket_types"
  },
  {
    "objectID": "reference/nodes.html#functions",
    "href": "reference/nodes.html#functions",
    "title": "nodes",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nadd_custom_node_group\n\n\n\nadd_custom_node_group_to_node\n\n\n\nchain_color\nGiven the input list of chain names, will create a node group which uses\n\n\nchain_selection\nGiven a an input_list, will create a node which takes an Integer input,\n\n\ncreate_custom_surface\n\n\n\ncreate_starting_node_tree\n\n\n\ncreate_starting_nodes_density\n\n\n\ncreate_starting_nodes_starfile\n\n\n\ngn_new_group_empty\n\n\n\nmol_append_node\n\n\n\nmol_base_material\nAppend MOL_atomic_material to the .blend file it it doesn’t already exist, and return that material.\n\n\nresid_multiple_selection\nReturns a node group that takes an integer input and creates a boolean\n\n\nrotation_matrix\nAdd a Rotation & Translation node from a 3x4 matrix."
  },
  {
    "objectID": "reference/nodes.html#nodes.add_custom_node_group",
    "href": "reference/nodes.html#nodes.add_custom_node_group",
    "title": "nodes",
    "section": "",
    "text": "add_custom_node_group(parent_group, node_name, location=\\[0, 0\\], width=200)"
  },
  {
    "objectID": "reference/nodes.html#nodes.add_custom_node_group_to_node",
    "href": "reference/nodes.html#nodes.add_custom_node_group_to_node",
    "title": "nodes",
    "section": "",
    "text": "add_custom_node_group_to_node(parent_group, node_name, location=\\[0, 0\\], width=200)"
  },
  {
    "objectID": "reference/nodes.html#nodes.chain_color",
    "href": "reference/nodes.html#nodes.chain_color",
    "title": "nodes",
    "section": "",
    "text": "chain_color(node_name, input_list, label_prefix='Chain ')\nGiven the input list of chain names, will create a node group which uses the chain_id named attribute to manually set the colours for each of the chains."
  },
  {
    "objectID": "reference/nodes.html#nodes.chain_selection",
    "href": "reference/nodes.html#nodes.chain_selection",
    "title": "nodes",
    "section": "",
    "text": "chain_selection(node_name, input_list, attribute, starting_value=0, label_prefix='')\nGiven a an input_list, will create a node which takes an Integer input, and has a boolean tick box for each item in the input list. The outputs will be the resulting selection and the inversion of the selection. Can contain a prefix for the resulting labels. Mostly used for constructing chain selections when required for specific proteins."
  },
  {
    "objectID": "reference/nodes.html#nodes.create_custom_surface",
    "href": "reference/nodes.html#nodes.create_custom_surface",
    "title": "nodes",
    "section": "",
    "text": "create_custom_surface(name, n_chains)"
  },
  {
    "objectID": "reference/nodes.html#nodes.create_starting_node_tree",
    "href": "reference/nodes.html#nodes.create_starting_node_tree",
    "title": "nodes",
    "section": "",
    "text": "create_starting_node_tree(obj, coll_frames, starting_style='atoms')"
  },
  {
    "objectID": "reference/nodes.html#nodes.create_starting_nodes_density",
    "href": "reference/nodes.html#nodes.create_starting_nodes_density",
    "title": "nodes",
    "section": "",
    "text": "create_starting_nodes_density(obj)"
  },
  {
    "objectID": "reference/nodes.html#nodes.create_starting_nodes_starfile",
    "href": "reference/nodes.html#nodes.create_starting_nodes_starfile",
    "title": "nodes",
    "section": "",
    "text": "create_starting_nodes_starfile(obj)"
  },
  {
    "objectID": "reference/nodes.html#nodes.gn_new_group_empty",
    "href": "reference/nodes.html#nodes.gn_new_group_empty",
    "title": "nodes",
    "section": "",
    "text": "gn_new_group_empty(name='Geometry Nodes')"
  },
  {
    "objectID": "reference/nodes.html#nodes.mol_append_node",
    "href": "reference/nodes.html#nodes.mol_append_node",
    "title": "nodes",
    "section": "",
    "text": "mol_append_node(node_name)"
  },
  {
    "objectID": "reference/nodes.html#nodes.mol_base_material",
    "href": "reference/nodes.html#nodes.mol_base_material",
    "title": "nodes",
    "section": "",
    "text": "mol_base_material()\nAppend MOL_atomic_material to the .blend file it it doesn’t already exist, and return that material."
  },
  {
    "objectID": "reference/nodes.html#nodes.resid_multiple_selection",
    "href": "reference/nodes.html#nodes.resid_multiple_selection",
    "title": "nodes",
    "section": "",
    "text": "resid_multiple_selection(node_name, input_resid_string)\nReturns a node group that takes an integer input and creates a boolean tick box for each item in the input list. Outputs are the selected residues and the inverse selection. Used for constructing chain selections in specific proteins."
  },
  {
    "objectID": "reference/nodes.html#nodes.rotation_matrix",
    "href": "reference/nodes.html#nodes.rotation_matrix",
    "title": "nodes",
    "section": "",
    "text": "rotation_matrix(node_group, mat, location=\\[0, 0\\], world_scale=0.01)\nAdd a Rotation & Translation node from a 3x4 matrix.\nArgs: node_group (type): Parent node group to add this new node to. mat (type): 3x4 rotation & translation matrix location (list, optional): Position to add the node in the node tree. Defaults to [0,0]. world_scale(float, optional): Scaling factor for the world. Defaults to 0.01. Returns: type: Newly created node tree."
  },
  {
    "objectID": "reference/pkg.html",
    "href": "reference/pkg.html",
    "title": "pkg",
    "section": "",
    "text": "``\nHandling installation of external python packages inside of Blender’s bundled python.\n\n\n\n\n\nName\nDescription\n\n\n\n\nADDON_DIR\nFolder for the addon on the local machine.\n\n\nPYPI_MIRROR\nPossible PyPi mirrors to install from.\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nget_pkgs\nRead a requirements file and extract package information into a dictionary.\n\n\nget_pypi_mirror_alias\nGet the available PyPI mirror aliases.\n\n\ninstall_all_packages\nInstall all packages listed in the ‘requirements.txt’ file.\n\n\ninstall_package\nInstall a Python package and its dependencies using pip.\n\n\nis_available\nCheck if a given package is available with the specified version.\n\n\nis_current\nCheck if the specified package is the current version.\n\n\nprocess_pypi_mirror_to_url\nProcess a PyPI mirror provider and return the corresponding URL.\n\n\nrun_python\nRuns pip command using the specified command list and returns the command output.\n\n\nstart_logging\nConfigure and start logging to a file.\n\n\n\n\n\n\nget_pkgs(requirements=None)\nRead a requirements file and extract package information into a dictionary.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nrequirements\nstr, optional\nThe path to the requirements file. If not provided, the function looks for a requirements.txt file in the same directory as the script.\nNone\n\n\n\n\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\ndict\nA dictionary containing package information. Each element of the dictionary is a dictionary containing the package name, version, and description.\n\n\n\n\n\n\nGiven the following requirements file:\nFlask==1.1.2 # A micro web framework for Python\npandas==1.2.3 # A fast, powerful, flexible, and easy-to-use data analysis and manipulation tool\nnumpy==1.20.1 # Fundamental package for scientific computing\nThe function would return the following dictionary:\n[\n    {\n        \"package\": \"Flask\",\n        \"version\": \"1.1.2\",\n        \"desc\": \"A micro web framework for Python\"\n    },\n    {\n        \"package\": \"pandas\",\n        \"version\": \"1.2.3\",\n        \"desc\": \"A fast, powerful, flexible, and easy-to-use data analysis and manipulation tool\"\n    },\n    {\n        \"package\": \"numpy\",\n        \"version\": \"1.20.1\",\n        \"desc\": \"Fundamental package for scientific computing\"\n    }\n]\n\n\n\n\nget_pypi_mirror_alias(self, context, edit_text)\nGet the available PyPI mirror aliases.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nself\nobject\nThe object instance.\nrequired\n\n\ncontext\n…\nThe context parameter (description missing).\nrequired\n\n\nedit_text\n…\nThe edit_text parameter (description missing).\nrequired\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nkeys_view\nA view object of the available PyPI mirror aliases.\n\n\n\n\n\n\n\ninstall_all_packages(pypi_mirror_provider='Default')\nInstall all packages listed in the ‘requirements.txt’ file.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npypi_mirror_provider\nstr, optional\nThe PyPI mirror to use for package installation. Defaults to ‘Default’, which uses the official PyPI repository.\n'Default'\n\n\n\n\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nlist\nA list of tuples containing the installation results for each package.\n\n\n\n\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nInstallationError\nIf there is an error during package installation.\n\n\n\n\n\n\nTo install all packages listed in the ‘requirements.txt’ file, run the following command:\ninstall_all_packages(pypi_mirror_provider='https://pypi.org/simple/')\n\n\n\n\ninstall_package(package, pypi_mirror_provider='Default')\nInstall a Python package and its dependencies using pip.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npackage\nstr\nThe name of the package to install.\nrequired\n\n\npypi_mirror_provider\nstr, optional\nThe name/url of the PyPI mirror provider to use. Default is ‘Default’.\n'Default'\n\n\n\n\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nlist\nA list of tuples containing the command list, return code, stdout, and stderr\n\n\nfor each pip command run.\n\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nValueError\nIf the package name is not provided.\n\n\n\n\n\n\nTo install the package ‘requests’ from the PyPI mirror ‘MyMirror’, use:\ninstall_package('requests', 'MyMirror')\n\n\n\n\nis_available(package, version=None)\nCheck if a given package is available with the specified version.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npackage\nstr\nThe name of the package to check.\nrequired\n\n\nversion\nstr, optional\nThe version of the package to check.\nNone\n\n\n\n\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nbool\nTrue if the package with the specified version is available, False otherwise.\n\n\n\n\n\n\n&gt;&gt;&gt; is_available('numpy', '1.20.1')\nTrue\n\n\n\n\nis_current(package)\nCheck if the specified package is the current version.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npackage\nstr\nThe name of the package to check.\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nbool\nTrue if the package is the current version, False otherwise.\n\n\n\n\n\n\n\nprocess_pypi_mirror_to_url(pypi_mirror_provider)\nProcess a PyPI mirror provider and return the corresponding URL.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npypi_mirror_provider\nstr\nThe PyPI mirror provider to process.\nrequired\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nstr\nThe URL of the PyPI mirror.\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nValueError\nIf the provided PyPI mirror provider is invalid.\n\n\n\n\n\n\n\nrun_python(cmd_list=None, mirror_url='', timeout=600)\nRuns pip command using the specified command list and returns the command output.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncmd_list\nlist, optional\nList of pip commands to be executed. Defaults to None.\nNone\n\n\nmirror_url\nstr, optional\nURL of a package repository mirror to be used for the command. Defaults to ’’.\n''\n\n\ntimeout\nint, optional\nTime in seconds to wait for the command to complete. Defaults to 600.\n600\n\n\n\n\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\ntuple\nA tuple containing the command list, command return code, command standard output,\n\n\nand command standard error.\n\n\n\n\n\n\n\nInstall numpy using pip and print the command output\ncmd_list = [\"-m\", \"pip\", \"install\", \"numpy\"]\nmirror_url = 'https://pypi.org/simple/'\ncmd_output = run_python(cmd_list, mirror_url=mirror_url, timeout=300)\nprint(cmd_output)\n\n\n\n\nstart_logging(logfile_name='side-packages-install')\nConfigure and start logging to a file.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nlogfile_name\nstr, optional\nThe name of the log file. Defaults to ‘side-packages-install’.\n'side-packages-install'\n\n\n\n\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nlogging.Logger\nA Logger object that can be used to write log messages.\n\n\n\nThis function sets up a logging configuration with a specified log file name and logging level. The log file will be created in the ADDON_DIR/logs directory. If the directory does not exist, it will be created. The function returns a Logger object that can be used to write log messages."
  },
  {
    "objectID": "reference/pkg.html#attributes",
    "href": "reference/pkg.html#attributes",
    "title": "pkg",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nADDON_DIR\nFolder for the addon on the local machine.\n\n\nPYPI_MIRROR\nPossible PyPi mirrors to install from."
  },
  {
    "objectID": "reference/pkg.html#functions",
    "href": "reference/pkg.html#functions",
    "title": "pkg",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nget_pkgs\nRead a requirements file and extract package information into a dictionary.\n\n\nget_pypi_mirror_alias\nGet the available PyPI mirror aliases.\n\n\ninstall_all_packages\nInstall all packages listed in the ‘requirements.txt’ file.\n\n\ninstall_package\nInstall a Python package and its dependencies using pip.\n\n\nis_available\nCheck if a given package is available with the specified version.\n\n\nis_current\nCheck if the specified package is the current version.\n\n\nprocess_pypi_mirror_to_url\nProcess a PyPI mirror provider and return the corresponding URL.\n\n\nrun_python\nRuns pip command using the specified command list and returns the command output.\n\n\nstart_logging\nConfigure and start logging to a file."
  },
  {
    "objectID": "reference/pkg.html#pkg.get_pkgs",
    "href": "reference/pkg.html#pkg.get_pkgs",
    "title": "pkg",
    "section": "",
    "text": "get_pkgs(requirements=None)\nRead a requirements file and extract package information into a dictionary.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nrequirements\nstr, optional\nThe path to the requirements file. If not provided, the function looks for a requirements.txt file in the same directory as the script.\nNone\n\n\n\n\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\ndict\nA dictionary containing package information. Each element of the dictionary is a dictionary containing the package name, version, and description.\n\n\n\n\n\n\nGiven the following requirements file:\nFlask==1.1.2 # A micro web framework for Python\npandas==1.2.3 # A fast, powerful, flexible, and easy-to-use data analysis and manipulation tool\nnumpy==1.20.1 # Fundamental package for scientific computing\nThe function would return the following dictionary:\n[\n    {\n        \"package\": \"Flask\",\n        \"version\": \"1.1.2\",\n        \"desc\": \"A micro web framework for Python\"\n    },\n    {\n        \"package\": \"pandas\",\n        \"version\": \"1.2.3\",\n        \"desc\": \"A fast, powerful, flexible, and easy-to-use data analysis and manipulation tool\"\n    },\n    {\n        \"package\": \"numpy\",\n        \"version\": \"1.20.1\",\n        \"desc\": \"Fundamental package for scientific computing\"\n    }\n]"
  },
  {
    "objectID": "reference/pkg.html#pkg.get_pypi_mirror_alias",
    "href": "reference/pkg.html#pkg.get_pypi_mirror_alias",
    "title": "pkg",
    "section": "",
    "text": "get_pypi_mirror_alias(self, context, edit_text)\nGet the available PyPI mirror aliases.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nself\nobject\nThe object instance.\nrequired\n\n\ncontext\n…\nThe context parameter (description missing).\nrequired\n\n\nedit_text\n…\nThe edit_text parameter (description missing).\nrequired\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nkeys_view\nA view object of the available PyPI mirror aliases."
  },
  {
    "objectID": "reference/pkg.html#pkg.install_all_packages",
    "href": "reference/pkg.html#pkg.install_all_packages",
    "title": "pkg",
    "section": "",
    "text": "install_all_packages(pypi_mirror_provider='Default')\nInstall all packages listed in the ‘requirements.txt’ file.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npypi_mirror_provider\nstr, optional\nThe PyPI mirror to use for package installation. Defaults to ‘Default’, which uses the official PyPI repository.\n'Default'\n\n\n\n\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nlist\nA list of tuples containing the installation results for each package.\n\n\n\n\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nInstallationError\nIf there is an error during package installation.\n\n\n\n\n\n\nTo install all packages listed in the ‘requirements.txt’ file, run the following command:\ninstall_all_packages(pypi_mirror_provider='https://pypi.org/simple/')"
  },
  {
    "objectID": "reference/pkg.html#pkg.install_package",
    "href": "reference/pkg.html#pkg.install_package",
    "title": "pkg",
    "section": "",
    "text": "install_package(package, pypi_mirror_provider='Default')\nInstall a Python package and its dependencies using pip.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npackage\nstr\nThe name of the package to install.\nrequired\n\n\npypi_mirror_provider\nstr, optional\nThe name/url of the PyPI mirror provider to use. Default is ‘Default’.\n'Default'\n\n\n\n\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nlist\nA list of tuples containing the command list, return code, stdout, and stderr\n\n\nfor each pip command run.\n\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nValueError\nIf the package name is not provided.\n\n\n\n\n\n\nTo install the package ‘requests’ from the PyPI mirror ‘MyMirror’, use:\ninstall_package('requests', 'MyMirror')"
  },
  {
    "objectID": "reference/pkg.html#pkg.is_available",
    "href": "reference/pkg.html#pkg.is_available",
    "title": "pkg",
    "section": "",
    "text": "is_available(package, version=None)\nCheck if a given package is available with the specified version.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npackage\nstr\nThe name of the package to check.\nrequired\n\n\nversion\nstr, optional\nThe version of the package to check.\nNone\n\n\n\n\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nbool\nTrue if the package with the specified version is available, False otherwise.\n\n\n\n\n\n\n&gt;&gt;&gt; is_available('numpy', '1.20.1')\nTrue"
  },
  {
    "objectID": "reference/pkg.html#pkg.is_current",
    "href": "reference/pkg.html#pkg.is_current",
    "title": "pkg",
    "section": "",
    "text": "is_current(package)\nCheck if the specified package is the current version.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npackage\nstr\nThe name of the package to check.\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nbool\nTrue if the package is the current version, False otherwise."
  },
  {
    "objectID": "reference/pkg.html#pkg.process_pypi_mirror_to_url",
    "href": "reference/pkg.html#pkg.process_pypi_mirror_to_url",
    "title": "pkg",
    "section": "",
    "text": "process_pypi_mirror_to_url(pypi_mirror_provider)\nProcess a PyPI mirror provider and return the corresponding URL.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npypi_mirror_provider\nstr\nThe PyPI mirror provider to process.\nrequired\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nstr\nThe URL of the PyPI mirror.\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nValueError\nIf the provided PyPI mirror provider is invalid."
  },
  {
    "objectID": "reference/pkg.html#pkg.run_python",
    "href": "reference/pkg.html#pkg.run_python",
    "title": "pkg",
    "section": "",
    "text": "run_python(cmd_list=None, mirror_url='', timeout=600)\nRuns pip command using the specified command list and returns the command output.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncmd_list\nlist, optional\nList of pip commands to be executed. Defaults to None.\nNone\n\n\nmirror_url\nstr, optional\nURL of a package repository mirror to be used for the command. Defaults to ’’.\n''\n\n\ntimeout\nint, optional\nTime in seconds to wait for the command to complete. Defaults to 600.\n600\n\n\n\n\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\ntuple\nA tuple containing the command list, command return code, command standard output,\n\n\nand command standard error.\n\n\n\n\n\n\n\nInstall numpy using pip and print the command output\ncmd_list = [\"-m\", \"pip\", \"install\", \"numpy\"]\nmirror_url = 'https://pypi.org/simple/'\ncmd_output = run_python(cmd_list, mirror_url=mirror_url, timeout=300)\nprint(cmd_output)"
  },
  {
    "objectID": "reference/pkg.html#pkg.start_logging",
    "href": "reference/pkg.html#pkg.start_logging",
    "title": "pkg",
    "section": "",
    "text": "start_logging(logfile_name='side-packages-install')\nConfigure and start logging to a file.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nlogfile_name\nstr, optional\nThe name of the log file. Defaults to ‘side-packages-install’.\n'side-packages-install'\n\n\n\n\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nlogging.Logger\nA Logger object that can be used to write log messages.\n\n\n\nThis function sets up a logging configuration with a specified log file name and logging level. The log file will be created in the ADDON_DIR/logs directory. If the directory does not exist, it will be created. The function returns a Logger object that can be used to write log messages."
  }
]